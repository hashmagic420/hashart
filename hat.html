<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>H.A.T: HASHARTOOL</title>
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 20px;
        background-color: #E64A19;
        color: #333;
      }
      #toolbar {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        background-color: #fff;
        padding: 10px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        width: 90%;
        max-width: 1000px;
      }
      #toolbar button,
      #toolbar input[type="color"],
      #toolbar input[type="file"],
      #toolbar input[type="number"],
      #toolbar input[type="range"],
      #toolbar select {
        margin: 8px;
        padding: 8px;
        border: 1px solid #000;
        border-radius: 4px;
        background-color: #eee;
        cursor: pointer;
        font-size: 14px;
      }
      #toolbar button:hover,
      #toolbar input[type="color"]:hover,
      #toolbar input[type="file"]:hover,
      #toolbar input[type="number"]:hover,
      #toolbar input[type="range"]:hover {
        background-color: #ddd;
      }
      #canvasContainer {
        position: relative;
        width: 90vw;
        height: 60vh;
        max-width: 800px;
        max-height: 600px;
        border: 5px solid #000;
        background-color: #fafafa;
        user-select: none;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 20px;
        margin-bottom: 50px;
      }
      .drawingCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
      #brandText {
        margin-top: 20px;
        font-size: 30px;
        font-weight: 700;
        color: #ff0;
        text-align: center;
        font-family: Arial, sans-serif;
        width: 100%;
        text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000,
          1px 1px 0 #000;
      }
      #brandTextContainer {
        position: absolute;
        width: calc(100% - 20px);
        bottom: 0;
        border: 2px solid #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 10px 0;
      }
      #logo {
        width: 100px;
        image-rendering: pixelated;
      }
      @media (max-width: 768px) {
        #toolbar {
          flex-direction: column;
          align-items: center;
        }
        #canvasContainer {
          width: 85vw;
          height: 50vh;
        }
      }
    </style>
  </head>
  <body>
    <div id="toolbar">
      <button id="addLayerBtn">Add Layer</button>
      <button id="clearLayerBtn">Clear Active Layer</button>
      <select id="layerSelect"></select>
      <input type="color" id="colorPicker" value="#000000" />
      <input type="range" id="brushSize" min="1" max="20" value="5" />
      <button id="undoBtn">Undo</button>
      <button id="eraseBtn">Erase</button>
      <input type="color" id="fillColor" value="#ffffff" />
      <button id="fillBtn">Fill Layer</button>
      <input type="file" id="importImage" accept=".png, .webp" />
      <button id="convertToWebP">Save as WEBP</button>
      <button id="convertToPNG">Save as PNG</button>
      <button id="compressAndDownload">Compress & Download</button>
      <button id="compressBtn">Compress Canvas</button>
      <button id="decompressBtn">Decompress Canvas</button>
      <div id="canvasSizeControls">
        <input type="number" id="canvasWidth" placeholder="Width" value="800" />
        <input
          type="number"
          id="canvasHeight"
          placeholder="Height"
          value="600"
        />
        <button id="resizeCanvas">Resize Canvas</button>
      </div>
      <button id="exportHTML">Export as HTML</button>
    </div>
    <div id="canvasContainer"></div>
    <img
      id="logo"
      src="data:image/webp;base64,Qk1aAQAAAAAAABoAAAAMAAAACgAKAAEAGAAAQOkAAAAAQOkAAAAAAAAAAAAAAAAAQOkAAAAAQOkAAAAAAADU/wAAAADU/wDU/wDU/wDU/wAAAADU/wAAAAAAAAAAANT/ANT/AAAAAAAAAAAAAAAAANT/ANT/AAAAAAAAAAAA1P8A1P8AAAAA1P8A1P8AAAAA1P8A1P8AAAAAAAAAAADU/wDU/wDU/wDU/wDU/wDU/wDU/wDU/wAAAAAAAAAAANT/ANT/ANT/AAAAAAAAANT/ANT/ANT/AAAAAAAAQOkAAAAA1P8A1P8A1P8A1P8A1P8A1P8AAAAAQOkAAAAAAADU/wDU/wDU/wDU/wDU/wDU/wDU/wDU/wAAAAAAAEDpAAAAANT/AAAAAAAAAAAAAAAAANT/AAAAAEDpAAAAQOkAQOkAAAAAQOkAQOkAQOkAQOkAAAAAQOkAQOkAAA=="
      alt="Logo"
    />
    <div id="brandText">hash.art</div>
    <script>
      !(function (t, e) {
        "object" == typeof exports && "undefined" != typeof module
          ? e(exports)
          : "function" == typeof define && define.amd
          ? define(["exports"], e)
          : e(
              ((t =
                "undefined" != typeof globalThis
                  ? globalThis
                  : t || self).pako = {})
            );
      })(this, function (t) {
        "use strict";
        function e(t) {
          let e = t.length;
          for (; --e >= 0; ) t[e] = 0;
        }
        const a = new Uint8Array([
            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
            4, 5, 5, 5, 5, 0,
          ]),
          n = new Uint8Array([
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9,
            10, 10, 11, 11, 12, 12, 13, 13,
          ]),
          i = new Uint8Array([
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7,
          ]),
          s = new Uint8Array([
            16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
          ]),
          r = new Array(576);
        e(r);
        const o = new Array(60);
        e(o);
        const l = new Array(512);
        e(l);
        const d = new Array(256);
        e(d);
        const h = new Array(29);
        e(h);
        const c = new Array(30);
        function _(t, e, a, n, i) {
          (this.static_tree = t),
            (this.extra_bits = e),
            (this.extra_base = a),
            (this.elems = n),
            (this.max_length = i),
            (this.has_stree = t && t.length);
        }
        let f, u, g;
        function m(t, e) {
          (this.dyn_tree = t), (this.max_code = 0), (this.stat_desc = e);
        }
        e(c);
        const w = (t) => (t < 256 ? l[t] : l[256 + (t >>> 7)]),
          b = (t, e) => {
            (t.pending_buf[t.pending++] = 255 & e),
              (t.pending_buf[t.pending++] = (e >>> 8) & 255);
          },
          p = (t, e, a) => {
            t.bi_valid > 16 - a
              ? ((t.bi_buf |= (e << t.bi_valid) & 65535),
                b(t, t.bi_buf),
                (t.bi_buf = e >> (16 - t.bi_valid)),
                (t.bi_valid += a - 16))
              : ((t.bi_buf |= (e << t.bi_valid) & 65535), (t.bi_valid += a));
          },
          v = (t, e, a) => {
            p(t, a[2 * e], a[2 * e + 1]);
          },
          k = (t, e) => {
            let a = 0;
            do {
              (a |= 1 & t), (t >>>= 1), (a <<= 1);
            } while (--e > 0);
            return a >>> 1;
          },
          y = (t, e, a) => {
            const n = new Array(16);
            let i,
              s,
              r = 0;
            for (i = 1; i <= 15; i++) n[i] = r = (r + a[i - 1]) << 1;
            for (s = 0; s <= e; s++) {
              let e = t[2 * s + 1];
              0 !== e && (t[2 * s] = k(n[e]++, e));
            }
          },
          x = (t) => {
            let e;
            for (e = 0; e < 286; e++) t.dyn_ltree[2 * e] = 0;
            for (e = 0; e < 30; e++) t.dyn_dtree[2 * e] = 0;
            for (e = 0; e < 19; e++) t.bl_tree[2 * e] = 0;
            (t.dyn_ltree[512] = 1),
              (t.opt_len = t.static_len = 0),
              (t.last_lit = t.matches = 0);
          },
          E = (t) => {
            t.bi_valid > 8
              ? b(t, t.bi_buf)
              : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf),
              (t.bi_buf = 0),
              (t.bi_valid = 0);
          },
          z = (t, e, a, n) => {
            const i = 2 * e,
              s = 2 * a;
            return t[i] < t[s] || (t[i] === t[s] && n[e] <= n[a]);
          },
          A = (t, e, a) => {
            const n = t.heap[a];
            let i = a << 1;
            for (
              ;
              i <= t.heap_len &&
              (i < t.heap_len && z(e, t.heap[i + 1], t.heap[i], t.depth) && i++,
              !z(e, n, t.heap[i], t.depth));

            )
              (t.heap[a] = t.heap[i]), (a = i), (i <<= 1);
            t.heap[a] = n;
          },
          R = (t, e, i) => {
            let s,
              r,
              o,
              l,
              _ = 0;
            if (0 !== t.last_lit)
              do {
                (s =
                  (t.pending_buf[t.d_buf + 2 * _] << 8) |
                  t.pending_buf[t.d_buf + 2 * _ + 1]),
                  (r = t.pending_buf[t.l_buf + _]),
                  _++,
                  0 === s
                    ? v(t, r, e)
                    : ((o = d[r]),
                      v(t, o + 256 + 1, e),
                      (l = a[o]),
                      0 !== l && ((r -= h[o]), p(t, r, l)),
                      s--,
                      (o = w(s)),
                      v(t, o, i),
                      (l = n[o]),
                      0 !== l && ((s -= c[o]), p(t, s, l)));
              } while (_ < t.last_lit);
            v(t, 256, e);
          },
          L = (t, e) => {
            const a = e.dyn_tree,
              n = e.stat_desc.static_tree,
              i = e.stat_desc.has_stree,
              s = e.stat_desc.elems;
            let r,
              o,
              l,
              d = -1;
            for (t.heap_len = 0, t.heap_max = 573, r = 0; r < s; r++)
              0 !== a[2 * r]
                ? ((t.heap[++t.heap_len] = d = r), (t.depth[r] = 0))
                : (a[2 * r + 1] = 0);
            for (; t.heap_len < 2; )
              (l = t.heap[++t.heap_len] = d < 2 ? ++d : 0),
                (a[2 * l] = 1),
                (t.depth[l] = 0),
                t.opt_len--,
                i && (t.static_len -= n[2 * l + 1]);
            for (e.max_code = d, r = t.heap_len >> 1; r >= 1; r--) A(t, a, r);
            l = s;
            do {
              (r = t.heap[1]),
                (t.heap[1] = t.heap[t.heap_len--]),
                A(t, a, 1),
                (o = t.heap[1]),
                (t.heap[--t.heap_max] = r),
                (t.heap[--t.heap_max] = o),
                (a[2 * l] = a[2 * r] + a[2 * o]),
                (t.depth[l] =
                  (t.depth[r] >= t.depth[o] ? t.depth[r] : t.depth[o]) + 1),
                (a[2 * r + 1] = a[2 * o + 1] = l),
                (t.heap[1] = l++),
                A(t, a, 1);
            } while (t.heap_len >= 2);
            (t.heap[--t.heap_max] = t.heap[1]),
              ((t, e) => {
                const a = e.dyn_tree,
                  n = e.max_code,
                  i = e.stat_desc.static_tree,
                  s = e.stat_desc.has_stree,
                  r = e.stat_desc.extra_bits,
                  o = e.stat_desc.extra_base,
                  l = e.stat_desc.max_length;
                let d,
                  h,
                  c,
                  _,
                  f,
                  u,
                  g = 0;
                for (_ = 0; _ <= 15; _++) t.bl_count[_] = 0;
                for (
                  a[2 * t.heap[t.heap_max] + 1] = 0, d = t.heap_max + 1;
                  d < 573;
                  d++
                )
                  (h = t.heap[d]),
                    (_ = a[2 * a[2 * h + 1] + 1] + 1),
                    _ > l && ((_ = l), g++),
                    (a[2 * h + 1] = _),
                    h > n ||
                      (t.bl_count[_]++,
                      (f = 0),
                      h >= o && (f = r[h - o]),
                      (u = a[2 * h]),
                      (t.opt_len += u * (_ + f)),
                      s && (t.static_len += u * (i[2 * h + 1] + f)));
                if (0 !== g) {
                  do {
                    for (_ = l - 1; 0 === t.bl_count[_]; ) _--;
                    t.bl_count[_]--,
                      (t.bl_count[_ + 1] += 2),
                      t.bl_count[l]--,
                      (g -= 2);
                  } while (g > 0);
                  for (_ = l; 0 !== _; _--)
                    for (h = t.bl_count[_]; 0 !== h; )
                      (c = t.heap[--d]),
                        c > n ||
                          (a[2 * c + 1] !== _ &&
                            ((t.opt_len += (_ - a[2 * c + 1]) * a[2 * c]),
                            (a[2 * c + 1] = _)),
                          h--);
                }
              })(t, e),
              y(a, d, t.bl_count);
          },
          U = (t, e, a) => {
            let n,
              i,
              s = -1,
              r = e[1],
              o = 0,
              l = 7,
              d = 4;
            for (
              0 === r && ((l = 138), (d = 3)),
                e[2 * (a + 1) + 1] = 65535,
                n = 0;
              n <= a;
              n++
            )
              (i = r),
                (r = e[2 * (n + 1) + 1]),
                (++o < l && i === r) ||
                  (o < d
                    ? (t.bl_tree[2 * i] += o)
                    : 0 !== i
                    ? (i !== s && t.bl_tree[2 * i]++, t.bl_tree[32]++)
                    : o <= 10
                    ? t.bl_tree[34]++
                    : t.bl_tree[36]++,
                  (o = 0),
                  (s = i),
                  0 === r
                    ? ((l = 138), (d = 3))
                    : i === r
                    ? ((l = 6), (d = 3))
                    : ((l = 7), (d = 4)));
          },
          B = (t, e, a) => {
            let n,
              i,
              s = -1,
              r = e[1],
              o = 0,
              l = 7,
              d = 4;
            for (0 === r && ((l = 138), (d = 3)), n = 0; n <= a; n++)
              if (((i = r), (r = e[2 * (n + 1) + 1]), !(++o < l && i === r))) {
                if (o < d)
                  do {
                    v(t, i, t.bl_tree);
                  } while (0 != --o);
                else
                  0 !== i
                    ? (i !== s && (v(t, i, t.bl_tree), o--),
                      v(t, 16, t.bl_tree),
                      p(t, o - 3, 2))
                    : o <= 10
                    ? (v(t, 17, t.bl_tree), p(t, o - 3, 3))
                    : (v(t, 18, t.bl_tree), p(t, o - 11, 7));
                (o = 0),
                  (s = i),
                  0 === r
                    ? ((l = 138), (d = 3))
                    : i === r
                    ? ((l = 6), (d = 3))
                    : ((l = 7), (d = 4));
              }
          };
        let Z = !1;
        const I = (t, e, a, n) => {
          p(t, 0 + (n ? 1 : 0), 3),
            ((t, e, a, n) => {
              E(t),
                b(t, a),
                b(t, ~a),
                t.pending_buf.set(t.window.subarray(e, e + a), t.pending),
                (t.pending += a);
            })(t, e, a);
        };
        var S = {
            _tr_init: (t) => {
              Z ||
                ((() => {
                  let t, e, s, m, w;
                  const b = new Array(16);
                  for (s = 0, m = 0; m < 28; m++)
                    for (h[m] = s, t = 0; t < 1 << a[m]; t++) d[s++] = m;
                  for (d[s - 1] = m, w = 0, m = 0; m < 16; m++)
                    for (c[m] = w, t = 0; t < 1 << n[m]; t++) l[w++] = m;
                  for (w >>= 7; m < 30; m++)
                    for (c[m] = w << 7, t = 0; t < 1 << (n[m] - 7); t++)
                      l[256 + w++] = m;
                  for (e = 0; e <= 15; e++) b[e] = 0;
                  for (t = 0; t <= 143; ) (r[2 * t + 1] = 8), t++, b[8]++;
                  for (; t <= 255; ) (r[2 * t + 1] = 9), t++, b[9]++;
                  for (; t <= 279; ) (r[2 * t + 1] = 7), t++, b[7]++;
                  for (; t <= 287; ) (r[2 * t + 1] = 8), t++, b[8]++;
                  for (y(r, 287, b), t = 0; t < 30; t++)
                    (o[2 * t + 1] = 5), (o[2 * t] = k(t, 5));
                  (f = new _(r, a, 257, 286, 15)),
                    (u = new _(o, n, 0, 30, 15)),
                    (g = new _(new Array(0), i, 0, 19, 7));
                })(),
                (Z = !0)),
                (t.l_desc = new m(t.dyn_ltree, f)),
                (t.d_desc = new m(t.dyn_dtree, u)),
                (t.bl_desc = new m(t.bl_tree, g)),
                (t.bi_buf = 0),
                (t.bi_valid = 0),
                x(t);
            },
            _tr_stored_block: I,
            _tr_flush_block: (t, e, a, n) => {
              let i,
                l,
                d = 0;
              t.level > 0
                ? (2 === t.strm.data_type &&
                    (t.strm.data_type = ((t) => {
                      let e,
                        a = 4093624447;
                      for (e = 0; e <= 31; e++, a >>>= 1)
                        if (1 & a && 0 !== t.dyn_ltree[2 * e]) return 0;
                      if (
                        0 !== t.dyn_ltree[18] ||
                        0 !== t.dyn_ltree[20] ||
                        0 !== t.dyn_ltree[26]
                      )
                        return 1;
                      for (e = 32; e < 256; e++)
                        if (0 !== t.dyn_ltree[2 * e]) return 1;
                      return 0;
                    })(t)),
                  L(t, t.l_desc),
                  L(t, t.d_desc),
                  (d = ((t) => {
                    let e;
                    for (
                      U(t, t.dyn_ltree, t.l_desc.max_code),
                        U(t, t.dyn_dtree, t.d_desc.max_code),
                        L(t, t.bl_desc),
                        e = 18;
                      e >= 3 && 0 === t.bl_tree[2 * s[e] + 1];
                      e--
                    );
                    return (t.opt_len += 3 * (e + 1) + 5 + 5 + 4), e;
                  })(t)),
                  (i = (t.opt_len + 3 + 7) >>> 3),
                  (l = (t.static_len + 3 + 7) >>> 3),
                  l <= i && (i = l))
                : (i = l = a + 5),
                a + 4 <= i && -1 !== e
                  ? I(t, e, a, n)
                  : 4 === t.strategy || l === i
                  ? (p(t, 2 + (n ? 1 : 0), 3), R(t, r, o))
                  : (p(t, 4 + (n ? 1 : 0), 3),
                    ((t, e, a, n) => {
                      let i;
                      for (
                        p(t, e - 257, 5), p(t, a - 1, 5), p(t, n - 4, 4), i = 0;
                        i < n;
                        i++
                      )
                        p(t, t.bl_tree[2 * s[i] + 1], 3);
                      B(t, t.dyn_ltree, e - 1), B(t, t.dyn_dtree, a - 1);
                    })(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, d + 1),
                    R(t, t.dyn_ltree, t.dyn_dtree)),
                x(t),
                n && E(t);
            },
            _tr_tally: (t, e, a) => (
              (t.pending_buf[t.d_buf + 2 * t.last_lit] = (e >>> 8) & 255),
              (t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e),
              (t.pending_buf[t.l_buf + t.last_lit] = 255 & a),
              t.last_lit++,
              0 === e
                ? t.dyn_ltree[2 * a]++
                : (t.matches++,
                  e--,
                  t.dyn_ltree[2 * (d[a] + 256 + 1)]++,
                  t.dyn_dtree[2 * w(e)]++),
              t.last_lit === t.lit_bufsize - 1
            ),
            _tr_align: (t) => {
              p(t, 2, 3),
                v(t, 256, r),
                ((t) => {
                  16 === t.bi_valid
                    ? (b(t, t.bi_buf), (t.bi_buf = 0), (t.bi_valid = 0))
                    : t.bi_valid >= 8 &&
                      ((t.pending_buf[t.pending++] = 255 & t.bi_buf),
                      (t.bi_buf >>= 8),
                      (t.bi_valid -= 8));
                })(t);
            },
          },
          O = (t, e, a, n) => {
            let i = (65535 & t) | 0,
              s = ((t >>> 16) & 65535) | 0,
              r = 0;
            for (; 0 !== a; ) {
              (r = a > 2e3 ? 2e3 : a), (a -= r);
              do {
                (i = (i + e[n++]) | 0), (s = (s + i) | 0);
              } while (--r);
              (i %= 65521), (s %= 65521);
            }
            return i | (s << 16) | 0;
          };
        const C = new Uint32Array(
          (() => {
            let t,
              e = [];
            for (var a = 0; a < 256; a++) {
              t = a;
              for (var n = 0; n < 8; n++)
                t = 1 & t ? 3988292384 ^ (t >>> 1) : t >>> 1;
              e[a] = t;
            }
            return e;
          })()
        );
        var T = (t, e, a, n) => {
            const i = C,
              s = n + a;
            t ^= -1;
            for (let a = n; a < s; a++) t = (t >>> 8) ^ i[255 & (t ^ e[a])];
            return -1 ^ t;
          },
          D = {
            2: "need dictionary",
            1: "stream end",
            0: "",
            "-1": "file error",
            "-2": "stream error",
            "-3": "data error",
            "-4": "insufficient memory",
            "-5": "buffer error",
            "-6": "incompatible version",
          },
          F = {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_TREES: 6,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_MEM_ERROR: -4,
            Z_BUF_ERROR: -5,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            Z_BINARY: 0,
            Z_TEXT: 1,
            Z_UNKNOWN: 2,
            Z_DEFLATED: 8,
          };
        const {
            _tr_init: N,
            _tr_stored_block: H,
            _tr_flush_block: M,
            _tr_tally: j,
            _tr_align: P,
          } = S,
          {
            Z_NO_FLUSH: W,
            Z_PARTIAL_FLUSH: Y,
            Z_FULL_FLUSH: K,
            Z_FINISH: X,
            Z_BLOCK: $,
            Z_OK: G,
            Z_STREAM_END: q,
            Z_STREAM_ERROR: J,
            Z_DATA_ERROR: Q,
            Z_BUF_ERROR: V,
            Z_DEFAULT_COMPRESSION: tt,
            Z_FILTERED: et,
            Z_HUFFMAN_ONLY: at,
            Z_RLE: nt,
            Z_FIXED: it,
            Z_DEFAULT_STRATEGY: st,
            Z_UNKNOWN: rt,
            Z_DEFLATED: ot,
          } = F,
          lt = 258,
          dt = 262,
          ht = 103,
          ct = 113,
          _t = 666,
          ft = (t, e) => ((t.msg = D[e]), e),
          ut = (t) => (t << 1) - (t > 4 ? 9 : 0),
          gt = (t) => {
            let e = t.length;
            for (; --e >= 0; ) t[e] = 0;
          };
        let mt = (t, e, a) => ((e << t.hash_shift) ^ a) & t.hash_mask;
        const wt = (t) => {
            const e = t.state;
            let a = e.pending;
            a > t.avail_out && (a = t.avail_out),
              0 !== a &&
                (t.output.set(
                  e.pending_buf.subarray(e.pending_out, e.pending_out + a),
                  t.next_out
                ),
                (t.next_out += a),
                (e.pending_out += a),
                (t.total_out += a),
                (t.avail_out -= a),
                (e.pending -= a),
                0 === e.pending && (e.pending_out = 0));
          },
          bt = (t, e) => {
            M(
              t,
              t.block_start >= 0 ? t.block_start : -1,
              t.strstart - t.block_start,
              e
            ),
              (t.block_start = t.strstart),
              wt(t.strm);
          },
          pt = (t, e) => {
            t.pending_buf[t.pending++] = e;
          },
          vt = (t, e) => {
            (t.pending_buf[t.pending++] = (e >>> 8) & 255),
              (t.pending_buf[t.pending++] = 255 & e);
          },
          kt = (t, e, a, n) => {
            let i = t.avail_in;
            return (
              i > n && (i = n),
              0 === i
                ? 0
                : ((t.avail_in -= i),
                  e.set(t.input.subarray(t.next_in, t.next_in + i), a),
                  1 === t.state.wrap
                    ? (t.adler = O(t.adler, e, i, a))
                    : 2 === t.state.wrap && (t.adler = T(t.adler, e, i, a)),
                  (t.next_in += i),
                  (t.total_in += i),
                  i)
            );
          },
          yt = (t, e) => {
            let a,
              n,
              i = t.max_chain_length,
              s = t.strstart,
              r = t.prev_length,
              o = t.nice_match;
            const l =
                t.strstart > t.w_size - dt ? t.strstart - (t.w_size - dt) : 0,
              d = t.window,
              h = t.w_mask,
              c = t.prev,
              _ = t.strstart + lt;
            let f = d[s + r - 1],
              u = d[s + r];
            t.prev_length >= t.good_match && (i >>= 2),
              o > t.lookahead && (o = t.lookahead);
            do {
              if (
                ((a = e),
                d[a + r] === u &&
                  d[a + r - 1] === f &&
                  d[a] === d[s] &&
                  d[++a] === d[s + 1])
              ) {
                (s += 2), a++;
                do {} while (
                  d[++s] === d[++a] &&
                  d[++s] === d[++a] &&
                  d[++s] === d[++a] &&
                  d[++s] === d[++a] &&
                  d[++s] === d[++a] &&
                  d[++s] === d[++a] &&
                  d[++s] === d[++a] &&
                  d[++s] === d[++a] &&
                  s < _
                );
                if (((n = lt - (_ - s)), (s = _ - lt), n > r)) {
                  if (((t.match_start = e), (r = n), n >= o)) break;
                  (f = d[s + r - 1]), (u = d[s + r]);
                }
              }
            } while ((e = c[e & h]) > l && 0 != --i);
            return r <= t.lookahead ? r : t.lookahead;
          },
          xt = (t) => {
            const e = t.w_size;
            let a, n, i, s, r;
            do {
              if (
                ((s = t.window_size - t.lookahead - t.strstart),
                t.strstart >= e + (e - dt))
              ) {
                t.window.set(t.window.subarray(e, e + e), 0),
                  (t.match_start -= e),
                  (t.strstart -= e),
                  (t.block_start -= e),
                  (n = t.hash_size),
                  (a = n);
                do {
                  (i = t.head[--a]), (t.head[a] = i >= e ? i - e : 0);
                } while (--n);
                (n = e), (a = n);
                do {
                  (i = t.prev[--a]), (t.prev[a] = i >= e ? i - e : 0);
                } while (--n);
                s += e;
              }
              if (0 === t.strm.avail_in) break;
              if (
                ((n = kt(t.strm, t.window, t.strstart + t.lookahead, s)),
                (t.lookahead += n),
                t.lookahead + t.insert >= 3)
              )
                for (
                  r = t.strstart - t.insert,
                    t.ins_h = t.window[r],
                    t.ins_h = mt(t, t.ins_h, t.window[r + 1]);
                  t.insert &&
                  ((t.ins_h = mt(t, t.ins_h, t.window[r + 3 - 1])),
                  (t.prev[r & t.w_mask] = t.head[t.ins_h]),
                  (t.head[t.ins_h] = r),
                  r++,
                  t.insert--,
                  !(t.lookahead + t.insert < 3));

                );
            } while (t.lookahead < dt && 0 !== t.strm.avail_in);
          },
          Et = (t, e) => {
            let a, n;
            for (;;) {
              if (t.lookahead < dt) {
                if ((xt(t), t.lookahead < dt && e === W)) return 1;
                if (0 === t.lookahead) break;
              }
              if (
                ((a = 0),
                t.lookahead >= 3 &&
                  ((t.ins_h = mt(t, t.ins_h, t.window[t.strstart + 3 - 1])),
                  (a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
                  (t.head[t.ins_h] = t.strstart)),
                0 !== a &&
                  t.strstart - a <= t.w_size - dt &&
                  (t.match_length = yt(t, a)),
                t.match_length >= 3)
              )
                if (
                  ((n = j(t, t.strstart - t.match_start, t.match_length - 3)),
                  (t.lookahead -= t.match_length),
                  t.match_length <= t.max_lazy_match && t.lookahead >= 3)
                ) {
                  t.match_length--;
                  do {
                    t.strstart++,
                      (t.ins_h = mt(t, t.ins_h, t.window[t.strstart + 3 - 1])),
                      (a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
                      (t.head[t.ins_h] = t.strstart);
                  } while (0 != --t.match_length);
                  t.strstart++;
                } else
                  (t.strstart += t.match_length),
                    (t.match_length = 0),
                    (t.ins_h = t.window[t.strstart]),
                    (t.ins_h = mt(t, t.ins_h, t.window[t.strstart + 1]));
              else
                (n = j(t, 0, t.window[t.strstart])),
                  t.lookahead--,
                  t.strstart++;
              if (n && (bt(t, !1), 0 === t.strm.avail_out)) return 1;
            }
            return (
              (t.insert = t.strstart < 2 ? t.strstart : 2),
              e === X
                ? (bt(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                : t.last_lit && (bt(t, !1), 0 === t.strm.avail_out)
                ? 1
                : 2
            );
          },
          zt = (t, e) => {
            let a, n, i;
            for (;;) {
              if (t.lookahead < dt) {
                if ((xt(t), t.lookahead < dt && e === W)) return 1;
                if (0 === t.lookahead) break;
              }
              if (
                ((a = 0),
                t.lookahead >= 3 &&
                  ((t.ins_h = mt(t, t.ins_h, t.window[t.strstart + 3 - 1])),
                  (a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
                  (t.head[t.ins_h] = t.strstart)),
                (t.prev_length = t.match_length),
                (t.prev_match = t.match_start),
                (t.match_length = 2),
                0 !== a &&
                  t.prev_length < t.max_lazy_match &&
                  t.strstart - a <= t.w_size - dt &&
                  ((t.match_length = yt(t, a)),
                  t.match_length <= 5 &&
                    (t.strategy === et ||
                      (3 === t.match_length &&
                        t.strstart - t.match_start > 4096)) &&
                    (t.match_length = 2)),
                t.prev_length >= 3 && t.match_length <= t.prev_length)
              ) {
                (i = t.strstart + t.lookahead - 3),
                  (n = j(t, t.strstart - 1 - t.prev_match, t.prev_length - 3)),
                  (t.lookahead -= t.prev_length - 1),
                  (t.prev_length -= 2);
                do {
                  ++t.strstart <= i &&
                    ((t.ins_h = mt(t, t.ins_h, t.window[t.strstart + 3 - 1])),
                    (a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h]),
                    (t.head[t.ins_h] = t.strstart));
                } while (0 != --t.prev_length);
                if (
                  ((t.match_available = 0),
                  (t.match_length = 2),
                  t.strstart++,
                  n && (bt(t, !1), 0 === t.strm.avail_out))
                )
                  return 1;
              } else if (t.match_available) {
                if (
                  ((n = j(t, 0, t.window[t.strstart - 1])),
                  n && bt(t, !1),
                  t.strstart++,
                  t.lookahead--,
                  0 === t.strm.avail_out)
                )
                  return 1;
              } else (t.match_available = 1), t.strstart++, t.lookahead--;
            }
            return (
              t.match_available &&
                ((n = j(t, 0, t.window[t.strstart - 1])),
                (t.match_available = 0)),
              (t.insert = t.strstart < 2 ? t.strstart : 2),
              e === X
                ? (bt(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                : t.last_lit && (bt(t, !1), 0 === t.strm.avail_out)
                ? 1
                : 2
            );
          };
        function At(t, e, a, n, i) {
          (this.good_length = t),
            (this.max_lazy = e),
            (this.nice_length = a),
            (this.max_chain = n),
            (this.func = i);
        }
        const Rt = [
          new At(0, 0, 0, 0, (t, e) => {
            let a = 65535;
            for (
              a > t.pending_buf_size - 5 && (a = t.pending_buf_size - 5);
              ;

            ) {
              if (t.lookahead <= 1) {
                if ((xt(t), 0 === t.lookahead && e === W)) return 1;
                if (0 === t.lookahead) break;
              }
              (t.strstart += t.lookahead), (t.lookahead = 0);
              const n = t.block_start + a;
              if (
                (0 === t.strstart || t.strstart >= n) &&
                ((t.lookahead = t.strstart - n),
                (t.strstart = n),
                bt(t, !1),
                0 === t.strm.avail_out)
              )
                return 1;
              if (
                t.strstart - t.block_start >= t.w_size - dt &&
                (bt(t, !1), 0 === t.strm.avail_out)
              )
                return 1;
            }
            return (
              (t.insert = 0),
              e === X
                ? (bt(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                : (t.strstart > t.block_start && (bt(t, !1), t.strm.avail_out),
                  1)
            );
          }),
          new At(4, 4, 8, 4, Et),
          new At(4, 5, 16, 8, Et),
          new At(4, 6, 32, 32, Et),
          new At(4, 4, 16, 16, zt),
          new At(8, 16, 32, 32, zt),
          new At(8, 16, 128, 128, zt),
          new At(8, 32, 128, 256, zt),
          new At(32, 128, 258, 1024, zt),
          new At(32, 258, 258, 4096, zt),
        ];
        function Lt() {
          (this.strm = null),
            (this.status = 0),
            (this.pending_buf = null),
            (this.pending_buf_size = 0),
            (this.pending_out = 0),
            (this.pending = 0),
            (this.wrap = 0),
            (this.gzhead = null),
            (this.gzindex = 0),
            (this.method = ot),
            (this.last_flush = -1),
            (this.w_size = 0),
            (this.w_bits = 0),
            (this.w_mask = 0),
            (this.window = null),
            (this.window_size = 0),
            (this.prev = null),
            (this.head = null),
            (this.ins_h = 0),
            (this.hash_size = 0),
            (this.hash_bits = 0),
            (this.hash_mask = 0),
            (this.hash_shift = 0),
            (this.block_start = 0),
            (this.match_length = 0),
            (this.prev_match = 0),
            (this.match_available = 0),
            (this.strstart = 0),
            (this.match_start = 0),
            (this.lookahead = 0),
            (this.prev_length = 0),
            (this.max_chain_length = 0),
            (this.max_lazy_match = 0),
            (this.level = 0),
            (this.strategy = 0),
            (this.good_match = 0),
            (this.nice_match = 0),
            (this.dyn_ltree = new Uint16Array(1146)),
            (this.dyn_dtree = new Uint16Array(122)),
            (this.bl_tree = new Uint16Array(78)),
            gt(this.dyn_ltree),
            gt(this.dyn_dtree),
            gt(this.bl_tree),
            (this.l_desc = null),
            (this.d_desc = null),
            (this.bl_desc = null),
            (this.bl_count = new Uint16Array(16)),
            (this.heap = new Uint16Array(573)),
            gt(this.heap),
            (this.heap_len = 0),
            (this.heap_max = 0),
            (this.depth = new Uint16Array(573)),
            gt(this.depth),
            (this.l_buf = 0),
            (this.lit_bufsize = 0),
            (this.last_lit = 0),
            (this.d_buf = 0),
            (this.opt_len = 0),
            (this.static_len = 0),
            (this.matches = 0),
            (this.insert = 0),
            (this.bi_buf = 0),
            (this.bi_valid = 0);
        }
        const Ut = (t) => {
            if (!t || !t.state) return ft(t, J);
            (t.total_in = t.total_out = 0), (t.data_type = rt);
            const e = t.state;
            return (
              (e.pending = 0),
              (e.pending_out = 0),
              e.wrap < 0 && (e.wrap = -e.wrap),
              (e.status = e.wrap ? 42 : ct),
              (t.adler = 2 === e.wrap ? 0 : 1),
              (e.last_flush = W),
              N(e),
              G
            );
          },
          Bt = (t) => {
            const e = Ut(t);
            var a;
            return (
              e === G &&
                (((a = t.state).window_size = 2 * a.w_size),
                gt(a.head),
                (a.max_lazy_match = Rt[a.level].max_lazy),
                (a.good_match = Rt[a.level].good_length),
                (a.nice_match = Rt[a.level].nice_length),
                (a.max_chain_length = Rt[a.level].max_chain),
                (a.strstart = 0),
                (a.block_start = 0),
                (a.lookahead = 0),
                (a.insert = 0),
                (a.match_length = a.prev_length = 2),
                (a.match_available = 0),
                (a.ins_h = 0)),
              e
            );
          },
          Zt = (t, e, a, n, i, s) => {
            if (!t) return J;
            let r = 1;
            if (
              (e === tt && (e = 6),
              n < 0 ? ((r = 0), (n = -n)) : n > 15 && ((r = 2), (n -= 16)),
              i < 1 ||
                i > 9 ||
                a !== ot ||
                n < 8 ||
                n > 15 ||
                e < 0 ||
                e > 9 ||
                s < 0 ||
                s > it)
            )
              return ft(t, J);
            8 === n && (n = 9);
            const o = new Lt();
            return (
              (t.state = o),
              (o.strm = t),
              (o.wrap = r),
              (o.gzhead = null),
              (o.w_bits = n),
              (o.w_size = 1 << o.w_bits),
              (o.w_mask = o.w_size - 1),
              (o.hash_bits = i + 7),
              (o.hash_size = 1 << o.hash_bits),
              (o.hash_mask = o.hash_size - 1),
              (o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3)),
              (o.window = new Uint8Array(2 * o.w_size)),
              (o.head = new Uint16Array(o.hash_size)),
              (o.prev = new Uint16Array(o.w_size)),
              (o.lit_bufsize = 1 << (i + 6)),
              (o.pending_buf_size = 4 * o.lit_bufsize),
              (o.pending_buf = new Uint8Array(o.pending_buf_size)),
              (o.d_buf = 1 * o.lit_bufsize),
              (o.l_buf = 3 * o.lit_bufsize),
              (o.level = e),
              (o.strategy = s),
              (o.method = a),
              Bt(t)
            );
          };
        var It = Zt,
          St = (t, e) =>
            t && t.state
              ? 2 !== t.state.wrap
                ? J
                : ((t.state.gzhead = e), G)
              : J,
          Ot = (t, e) => {
            let a, n;
            if (!t || !t.state || e > $ || e < 0) return t ? ft(t, J) : J;
            const i = t.state;
            if (
              !t.output ||
              (!t.input && 0 !== t.avail_in) ||
              (i.status === _t && e !== X)
            )
              return ft(t, 0 === t.avail_out ? V : J);
            i.strm = t;
            const s = i.last_flush;
            if (((i.last_flush = e), 42 === i.status))
              if (2 === i.wrap)
                (t.adler = 0),
                  pt(i, 31),
                  pt(i, 139),
                  pt(i, 8),
                  i.gzhead
                    ? (pt(
                        i,
                        (i.gzhead.text ? 1 : 0) +
                          (i.gzhead.hcrc ? 2 : 0) +
                          (i.gzhead.extra ? 4 : 0) +
                          (i.gzhead.name ? 8 : 0) +
                          (i.gzhead.comment ? 16 : 0)
                      ),
                      pt(i, 255 & i.gzhead.time),
                      pt(i, (i.gzhead.time >> 8) & 255),
                      pt(i, (i.gzhead.time >> 16) & 255),
                      pt(i, (i.gzhead.time >> 24) & 255),
                      pt(
                        i,
                        9 === i.level
                          ? 2
                          : i.strategy >= at || i.level < 2
                          ? 4
                          : 0
                      ),
                      pt(i, 255 & i.gzhead.os),
                      i.gzhead.extra &&
                        i.gzhead.extra.length &&
                        (pt(i, 255 & i.gzhead.extra.length),
                        pt(i, (i.gzhead.extra.length >> 8) & 255)),
                      i.gzhead.hcrc &&
                        (t.adler = T(t.adler, i.pending_buf, i.pending, 0)),
                      (i.gzindex = 0),
                      (i.status = 69))
                    : (pt(i, 0),
                      pt(i, 0),
                      pt(i, 0),
                      pt(i, 0),
                      pt(i, 0),
                      pt(
                        i,
                        9 === i.level
                          ? 2
                          : i.strategy >= at || i.level < 2
                          ? 4
                          : 0
                      ),
                      pt(i, 3),
                      (i.status = ct));
              else {
                let e = (ot + ((i.w_bits - 8) << 4)) << 8,
                  a = -1;
                (a =
                  i.strategy >= at || i.level < 2
                    ? 0
                    : i.level < 6
                    ? 1
                    : 6 === i.level
                    ? 2
                    : 3),
                  (e |= a << 6),
                  0 !== i.strstart && (e |= 32),
                  (e += 31 - (e % 31)),
                  (i.status = ct),
                  vt(i, e),
                  0 !== i.strstart &&
                    (vt(i, t.adler >>> 16), vt(i, 65535 & t.adler)),
                  (t.adler = 1);
              }
            if (69 === i.status)
              if (i.gzhead.extra) {
                for (
                  a = i.pending;
                  i.gzindex < (65535 & i.gzhead.extra.length) &&
                  (i.pending !== i.pending_buf_size ||
                    (i.gzhead.hcrc &&
                      i.pending > a &&
                      (t.adler = T(t.adler, i.pending_buf, i.pending - a, a)),
                    wt(t),
                    (a = i.pending),
                    i.pending !== i.pending_buf_size));

                )
                  pt(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++;
                i.gzhead.hcrc &&
                  i.pending > a &&
                  (t.adler = T(t.adler, i.pending_buf, i.pending - a, a)),
                  i.gzindex === i.gzhead.extra.length &&
                    ((i.gzindex = 0), (i.status = 73));
              } else i.status = 73;
            if (73 === i.status)
              if (i.gzhead.name) {
                a = i.pending;
                do {
                  if (
                    i.pending === i.pending_buf_size &&
                    (i.gzhead.hcrc &&
                      i.pending > a &&
                      (t.adler = T(t.adler, i.pending_buf, i.pending - a, a)),
                    wt(t),
                    (a = i.pending),
                    i.pending === i.pending_buf_size)
                  ) {
                    n = 1;
                    break;
                  }
                  (n =
                    i.gzindex < i.gzhead.name.length
                      ? 255 & i.gzhead.name.charCodeAt(i.gzindex++)
                      : 0),
                    pt(i, n);
                } while (0 !== n);
                i.gzhead.hcrc &&
                  i.pending > a &&
                  (t.adler = T(t.adler, i.pending_buf, i.pending - a, a)),
                  0 === n && ((i.gzindex = 0), (i.status = 91));
              } else i.status = 91;
            if (91 === i.status)
              if (i.gzhead.comment) {
                a = i.pending;
                do {
                  if (
                    i.pending === i.pending_buf_size &&
                    (i.gzhead.hcrc &&
                      i.pending > a &&
                      (t.adler = T(t.adler, i.pending_buf, i.pending - a, a)),
                    wt(t),
                    (a = i.pending),
                    i.pending === i.pending_buf_size)
                  ) {
                    n = 1;
                    break;
                  }
                  (n =
                    i.gzindex < i.gzhead.comment.length
                      ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++)
                      : 0),
                    pt(i, n);
                } while (0 !== n);
                i.gzhead.hcrc &&
                  i.pending > a &&
                  (t.adler = T(t.adler, i.pending_buf, i.pending - a, a)),
                  0 === n && (i.status = ht);
              } else i.status = ht;
            if (
              (i.status === ht &&
                (i.gzhead.hcrc
                  ? (i.pending + 2 > i.pending_buf_size && wt(t),
                    i.pending + 2 <= i.pending_buf_size &&
                      (pt(i, 255 & t.adler),
                      pt(i, (t.adler >> 8) & 255),
                      (t.adler = 0),
                      (i.status = ct)))
                  : (i.status = ct)),
              0 !== i.pending)
            ) {
              if ((wt(t), 0 === t.avail_out)) return (i.last_flush = -1), G;
            } else if (0 === t.avail_in && ut(e) <= ut(s) && e !== X)
              return ft(t, V);
            if (i.status === _t && 0 !== t.avail_in) return ft(t, V);
            if (
              0 !== t.avail_in ||
              0 !== i.lookahead ||
              (e !== W && i.status !== _t)
            ) {
              let a =
                i.strategy === at
                  ? ((t, e) => {
                      let a;
                      for (;;) {
                        if (0 === t.lookahead && (xt(t), 0 === t.lookahead)) {
                          if (e === W) return 1;
                          break;
                        }
                        if (
                          ((t.match_length = 0),
                          (a = j(t, 0, t.window[t.strstart])),
                          t.lookahead--,
                          t.strstart++,
                          a && (bt(t, !1), 0 === t.strm.avail_out))
                        )
                          return 1;
                      }
                      return (
                        (t.insert = 0),
                        e === X
                          ? (bt(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                          : t.last_lit && (bt(t, !1), 0 === t.strm.avail_out)
                          ? 1
                          : 2
                      );
                    })(i, e)
                  : i.strategy === nt
                  ? ((t, e) => {
                      let a, n, i, s;
                      const r = t.window;
                      for (;;) {
                        if (t.lookahead <= lt) {
                          if ((xt(t), t.lookahead <= lt && e === W)) return 1;
                          if (0 === t.lookahead) break;
                        }
                        if (
                          ((t.match_length = 0),
                          t.lookahead >= 3 &&
                            t.strstart > 0 &&
                            ((i = t.strstart - 1),
                            (n = r[i]),
                            n === r[++i] && n === r[++i] && n === r[++i]))
                        ) {
                          s = t.strstart + lt;
                          do {} while (
                            n === r[++i] &&
                            n === r[++i] &&
                            n === r[++i] &&
                            n === r[++i] &&
                            n === r[++i] &&
                            n === r[++i] &&
                            n === r[++i] &&
                            n === r[++i] &&
                            i < s
                          );
                          (t.match_length = lt - (s - i)),
                            t.match_length > t.lookahead &&
                              (t.match_length = t.lookahead);
                        }
                        if (
                          (t.match_length >= 3
                            ? ((a = j(t, 1, t.match_length - 3)),
                              (t.lookahead -= t.match_length),
                              (t.strstart += t.match_length),
                              (t.match_length = 0))
                            : ((a = j(t, 0, t.window[t.strstart])),
                              t.lookahead--,
                              t.strstart++),
                          a && (bt(t, !1), 0 === t.strm.avail_out))
                        )
                          return 1;
                      }
                      return (
                        (t.insert = 0),
                        e === X
                          ? (bt(t, !0), 0 === t.strm.avail_out ? 3 : 4)
                          : t.last_lit && (bt(t, !1), 0 === t.strm.avail_out)
                          ? 1
                          : 2
                      );
                    })(i, e)
                  : Rt[i.level].func(i, e);
              if (((3 !== a && 4 !== a) || (i.status = _t), 1 === a || 3 === a))
                return 0 === t.avail_out && (i.last_flush = -1), G;
              if (
                2 === a &&
                (e === Y
                  ? P(i)
                  : e !== $ &&
                    (H(i, 0, 0, !1),
                    e === K &&
                      (gt(i.head),
                      0 === i.lookahead &&
                        ((i.strstart = 0),
                        (i.block_start = 0),
                        (i.insert = 0)))),
                wt(t),
                0 === t.avail_out)
              )
                return (i.last_flush = -1), G;
            }
            return e !== X
              ? G
              : i.wrap <= 0
              ? q
              : (2 === i.wrap
                  ? (pt(i, 255 & t.adler),
                    pt(i, (t.adler >> 8) & 255),
                    pt(i, (t.adler >> 16) & 255),
                    pt(i, (t.adler >> 24) & 255),
                    pt(i, 255 & t.total_in),
                    pt(i, (t.total_in >> 8) & 255),
                    pt(i, (t.total_in >> 16) & 255),
                    pt(i, (t.total_in >> 24) & 255))
                  : (vt(i, t.adler >>> 16), vt(i, 65535 & t.adler)),
                wt(t),
                i.wrap > 0 && (i.wrap = -i.wrap),
                0 !== i.pending ? G : q);
          },
          Ct = (t) => {
            if (!t || !t.state) return J;
            const e = t.state.status;
            return 42 !== e &&
              69 !== e &&
              73 !== e &&
              91 !== e &&
              e !== ht &&
              e !== ct &&
              e !== _t
              ? ft(t, J)
              : ((t.state = null), e === ct ? ft(t, Q) : G);
          },
          Tt = (t, e) => {
            let a = e.length;
            if (!t || !t.state) return J;
            const n = t.state,
              i = n.wrap;
            if (2 === i || (1 === i && 42 !== n.status) || n.lookahead)
              return J;
            if (
              (1 === i && (t.adler = O(t.adler, e, a, 0)),
              (n.wrap = 0),
              a >= n.w_size)
            ) {
              0 === i &&
                (gt(n.head),
                (n.strstart = 0),
                (n.block_start = 0),
                (n.insert = 0));
              let t = new Uint8Array(n.w_size);
              t.set(e.subarray(a - n.w_size, a), 0), (e = t), (a = n.w_size);
            }
            const s = t.avail_in,
              r = t.next_in,
              o = t.input;
            for (
              t.avail_in = a, t.next_in = 0, t.input = e, xt(n);
              n.lookahead >= 3;

            ) {
              let t = n.strstart,
                e = n.lookahead - 2;
              do {
                (n.ins_h = mt(n, n.ins_h, n.window[t + 3 - 1])),
                  (n.prev[t & n.w_mask] = n.head[n.ins_h]),
                  (n.head[n.ins_h] = t),
                  t++;
              } while (--e);
              (n.strstart = t), (n.lookahead = 2), xt(n);
            }
            return (
              (n.strstart += n.lookahead),
              (n.block_start = n.strstart),
              (n.insert = n.lookahead),
              (n.lookahead = 0),
              (n.match_length = n.prev_length = 2),
              (n.match_available = 0),
              (t.next_in = r),
              (t.input = o),
              (t.avail_in = s),
              (n.wrap = i),
              G
            );
          };
        const Dt = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
        var Ft = function (t) {
            const e = Array.prototype.slice.call(arguments, 1);
            for (; e.length; ) {
              const a = e.shift();
              if (a) {
                if ("object" != typeof a)
                  throw new TypeError(a + "must be non-object");
                for (const e in a) Dt(a, e) && (t[e] = a[e]);
              }
            }
            return t;
          },
          Nt = (t) => {
            let e = 0;
            for (let a = 0, n = t.length; a < n; a++) e += t[a].length;
            const a = new Uint8Array(e);
            for (let e = 0, n = 0, i = t.length; e < i; e++) {
              let i = t[e];
              a.set(i, n), (n += i.length);
            }
            return a;
          };
        let Ht = !0;
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (t) {
          Ht = !1;
        }
        const Mt = new Uint8Array(256);
        for (let t = 0; t < 256; t++)
          Mt[t] =
            t >= 252
              ? 6
              : t >= 248
              ? 5
              : t >= 240
              ? 4
              : t >= 224
              ? 3
              : t >= 192
              ? 2
              : 1;
        Mt[254] = Mt[254] = 1;
        var jt = (t) => {
            let e,
              a,
              n,
              i,
              s,
              r = t.length,
              o = 0;
            for (i = 0; i < r; i++)
              (a = t.charCodeAt(i)),
                55296 == (64512 & a) &&
                  i + 1 < r &&
                  ((n = t.charCodeAt(i + 1)),
                  56320 == (64512 & n) &&
                    ((a = 65536 + ((a - 55296) << 10) + (n - 56320)), i++)),
                (o += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4);
            for (e = new Uint8Array(o), s = 0, i = 0; s < o; i++)
              (a = t.charCodeAt(i)),
                55296 == (64512 & a) &&
                  i + 1 < r &&
                  ((n = t.charCodeAt(i + 1)),
                  56320 == (64512 & n) &&
                    ((a = 65536 + ((a - 55296) << 10) + (n - 56320)), i++)),
                a < 128
                  ? (e[s++] = a)
                  : a < 2048
                  ? ((e[s++] = 192 | (a >>> 6)), (e[s++] = 128 | (63 & a)))
                  : a < 65536
                  ? ((e[s++] = 224 | (a >>> 12)),
                    (e[s++] = 128 | ((a >>> 6) & 63)),
                    (e[s++] = 128 | (63 & a)))
                  : ((e[s++] = 240 | (a >>> 18)),
                    (e[s++] = 128 | ((a >>> 12) & 63)),
                    (e[s++] = 128 | ((a >>> 6) & 63)),
                    (e[s++] = 128 | (63 & a)));
            return e;
          },
          Pt = (t, e) => {
            let a, n;
            const i = e || t.length,
              s = new Array(2 * i);
            for (n = 0, a = 0; a < i; ) {
              let e = t[a++];
              if (e < 128) {
                s[n++] = e;
                continue;
              }
              let r = Mt[e];
              if (r > 4) (s[n++] = 65533), (a += r - 1);
              else {
                for (e &= 2 === r ? 31 : 3 === r ? 15 : 7; r > 1 && a < i; )
                  (e = (e << 6) | (63 & t[a++])), r--;
                r > 1
                  ? (s[n++] = 65533)
                  : e < 65536
                  ? (s[n++] = e)
                  : ((e -= 65536),
                    (s[n++] = 55296 | ((e >> 10) & 1023)),
                    (s[n++] = 56320 | (1023 & e)));
              }
            }
            return ((t, e) => {
              if (e < 65534 && t.subarray && Ht)
                return String.fromCharCode.apply(
                  null,
                  t.length === e ? t : t.subarray(0, e)
                );
              let a = "";
              for (let n = 0; n < e; n++) a += String.fromCharCode(t[n]);
              return a;
            })(s, n);
          },
          Wt = (t, e) => {
            (e = e || t.length) > t.length && (e = t.length);
            let a = e - 1;
            for (; a >= 0 && 128 == (192 & t[a]); ) a--;
            return a < 0 || 0 === a ? e : a + Mt[t[a]] > e ? a : e;
          },
          Yt = function () {
            (this.input = null),
              (this.next_in = 0),
              (this.avail_in = 0),
              (this.total_in = 0),
              (this.output = null),
              (this.next_out = 0),
              (this.avail_out = 0),
              (this.total_out = 0),
              (this.msg = ""),
              (this.state = null),
              (this.data_type = 2),
              (this.adler = 0);
          };
        const Kt = Object.prototype.toString,
          {
            Z_NO_FLUSH: Xt,
            Z_SYNC_FLUSH: $t,
            Z_FULL_FLUSH: Gt,
            Z_FINISH: qt,
            Z_OK: Jt,
            Z_STREAM_END: Qt,
            Z_DEFAULT_COMPRESSION: Vt,
            Z_DEFAULT_STRATEGY: te,
            Z_DEFLATED: ee,
          } = F;
        function ae(t) {
          this.options = Ft(
            {
              level: Vt,
              method: ee,
              chunkSize: 16384,
              windowBits: 15,
              memLevel: 8,
              strategy: te,
            },
            t || {}
          );
          let e = this.options;
          e.raw && e.windowBits > 0
            ? (e.windowBits = -e.windowBits)
            : e.gzip &&
              e.windowBits > 0 &&
              e.windowBits < 16 &&
              (e.windowBits += 16),
            (this.err = 0),
            (this.msg = ""),
            (this.ended = !1),
            (this.chunks = []),
            (this.strm = new Yt()),
            (this.strm.avail_out = 0);
          let a = It(
            this.strm,
            e.level,
            e.method,
            e.windowBits,
            e.memLevel,
            e.strategy
          );
          if (a !== Jt) throw new Error(D[a]);
          if ((e.header && St(this.strm, e.header), e.dictionary)) {
            let t;
            if (
              ((t =
                "string" == typeof e.dictionary
                  ? jt(e.dictionary)
                  : "[object ArrayBuffer]" === Kt.call(e.dictionary)
                  ? new Uint8Array(e.dictionary)
                  : e.dictionary),
              (a = Tt(this.strm, t)),
              a !== Jt)
            )
              throw new Error(D[a]);
            this._dict_set = !0;
          }
        }
        function ne(t, e) {
          const a = new ae(e);
          if ((a.push(t, !0), a.err)) throw a.msg || D[a.err];
          return a.result;
        }
        (ae.prototype.push = function (t, e) {
          const a = this.strm,
            n = this.options.chunkSize;
          let i, s;
          if (this.ended) return !1;
          for (
            s = e === ~~e ? e : !0 === e ? qt : Xt,
              "string" == typeof t
                ? (a.input = jt(t))
                : "[object ArrayBuffer]" === Kt.call(t)
                ? (a.input = new Uint8Array(t))
                : (a.input = t),
              a.next_in = 0,
              a.avail_in = a.input.length;
            ;

          )
            if (
              (0 === a.avail_out &&
                ((a.output = new Uint8Array(n)),
                (a.next_out = 0),
                (a.avail_out = n)),
              (s === $t || s === Gt) && a.avail_out <= 6)
            )
              this.onData(a.output.subarray(0, a.next_out)), (a.avail_out = 0);
            else {
              if (((i = Ot(a, s)), i === Qt))
                return (
                  a.next_out > 0 &&
                    this.onData(a.output.subarray(0, a.next_out)),
                  (i = Ct(this.strm)),
                  this.onEnd(i),
                  (this.ended = !0),
                  i === Jt
                );
              if (0 !== a.avail_out) {
                if (s > 0 && a.next_out > 0)
                  this.onData(a.output.subarray(0, a.next_out)),
                    (a.avail_out = 0);
                else if (0 === a.avail_in) break;
              } else this.onData(a.output);
            }
          return !0;
        }),
          (ae.prototype.onData = function (t) {
            this.chunks.push(t);
          }),
          (ae.prototype.onEnd = function (t) {
            t === Jt && (this.result = Nt(this.chunks)),
              (this.chunks = []),
              (this.err = t),
              (this.msg = this.strm.msg);
          });
        var ie = {
            Deflate: ae,
            deflate: ne,
            deflateRaw: function (t, e) {
              return ((e = e || {}).raw = !0), ne(t, e);
            },
            gzip: function (t, e) {
              return ((e = e || {}).gzip = !0), ne(t, e);
            },
            constants: F,
          },
          se = function (t, e) {
            let a,
              n,
              i,
              s,
              r,
              o,
              l,
              d,
              h,
              c,
              _,
              f,
              u,
              g,
              m,
              w,
              b,
              p,
              v,
              k,
              y,
              x,
              E,
              z;
            const A = t.state;
            (a = t.next_in),
              (E = t.input),
              (n = a + (t.avail_in - 5)),
              (i = t.next_out),
              (z = t.output),
              (s = i - (e - t.avail_out)),
              (r = i + (t.avail_out - 257)),
              (o = A.dmax),
              (l = A.wsize),
              (d = A.whave),
              (h = A.wnext),
              (c = A.window),
              (_ = A.hold),
              (f = A.bits),
              (u = A.lencode),
              (g = A.distcode),
              (m = (1 << A.lenbits) - 1),
              (w = (1 << A.distbits) - 1);
            t: do {
              f < 15 &&
                ((_ += E[a++] << f), (f += 8), (_ += E[a++] << f), (f += 8)),
                (b = u[_ & m]);
              e: for (;;) {
                if (
                  ((p = b >>> 24),
                  (_ >>>= p),
                  (f -= p),
                  (p = (b >>> 16) & 255),
                  0 === p)
                )
                  z[i++] = 65535 & b;
                else {
                  if (!(16 & p)) {
                    if (0 == (64 & p)) {
                      b = u[(65535 & b) + (_ & ((1 << p) - 1))];
                      continue e;
                    }
                    if (32 & p) {
                      A.mode = 12;
                      break t;
                    }
                    (t.msg = "invalid literal/length code"), (A.mode = 30);
                    break t;
                  }
                  (v = 65535 & b),
                    (p &= 15),
                    p &&
                      (f < p && ((_ += E[a++] << f), (f += 8)),
                      (v += _ & ((1 << p) - 1)),
                      (_ >>>= p),
                      (f -= p)),
                    f < 15 &&
                      ((_ += E[a++] << f),
                      (f += 8),
                      (_ += E[a++] << f),
                      (f += 8)),
                    (b = g[_ & w]);
                  a: for (;;) {
                    if (
                      ((p = b >>> 24),
                      (_ >>>= p),
                      (f -= p),
                      (p = (b >>> 16) & 255),
                      !(16 & p))
                    ) {
                      if (0 == (64 & p)) {
                        b = g[(65535 & b) + (_ & ((1 << p) - 1))];
                        continue a;
                      }
                      (t.msg = "invalid distance code"), (A.mode = 30);
                      break t;
                    }
                    if (
                      ((k = 65535 & b),
                      (p &= 15),
                      f < p &&
                        ((_ += E[a++] << f),
                        (f += 8),
                        f < p && ((_ += E[a++] << f), (f += 8))),
                      (k += _ & ((1 << p) - 1)),
                      k > o)
                    ) {
                      (t.msg = "invalid distance too far back"), (A.mode = 30);
                      break t;
                    }
                    if (((_ >>>= p), (f -= p), (p = i - s), k > p)) {
                      if (((p = k - p), p > d && A.sane)) {
                        (t.msg = "invalid distance too far back"),
                          (A.mode = 30);
                        break t;
                      }
                      if (((y = 0), (x = c), 0 === h)) {
                        if (((y += l - p), p < v)) {
                          v -= p;
                          do {
                            z[i++] = c[y++];
                          } while (--p);
                          (y = i - k), (x = z);
                        }
                      } else if (h < p) {
                        if (((y += l + h - p), (p -= h), p < v)) {
                          v -= p;
                          do {
                            z[i++] = c[y++];
                          } while (--p);
                          if (((y = 0), h < v)) {
                            (p = h), (v -= p);
                            do {
                              z[i++] = c[y++];
                            } while (--p);
                            (y = i - k), (x = z);
                          }
                        }
                      } else if (((y += h - p), p < v)) {
                        v -= p;
                        do {
                          z[i++] = c[y++];
                        } while (--p);
                        (y = i - k), (x = z);
                      }
                      for (; v > 2; )
                        (z[i++] = x[y++]),
                          (z[i++] = x[y++]),
                          (z[i++] = x[y++]),
                          (v -= 3);
                      v && ((z[i++] = x[y++]), v > 1 && (z[i++] = x[y++]));
                    } else {
                      y = i - k;
                      do {
                        (z[i++] = z[y++]),
                          (z[i++] = z[y++]),
                          (z[i++] = z[y++]),
                          (v -= 3);
                      } while (v > 2);
                      v && ((z[i++] = z[y++]), v > 1 && (z[i++] = z[y++]));
                    }
                    break;
                  }
                }
                break;
              }
            } while (a < n && i < r);
            (v = f >> 3),
              (a -= v),
              (f -= v << 3),
              (_ &= (1 << f) - 1),
              (t.next_in = a),
              (t.next_out = i),
              (t.avail_in = a < n ? n - a + 5 : 5 - (a - n)),
              (t.avail_out = i < r ? r - i + 257 : 257 - (i - r)),
              (A.hold = _),
              (A.bits = f);
          };
        const re = new Uint16Array([
            3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51,
            59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0,
          ]),
          oe = new Uint8Array([
            16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19,
            19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78,
          ]),
          le = new Uint16Array([
            1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385,
            513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385,
            24577, 0, 0,
          ]),
          de = new Uint8Array([
            16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23,
            23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64,
          ]);
        var he = (t, e, a, n, i, s, r, o) => {
          const l = o.bits;
          let d,
            h,
            c,
            _,
            f,
            u,
            g = 0,
            m = 0,
            w = 0,
            b = 0,
            p = 0,
            v = 0,
            k = 0,
            y = 0,
            x = 0,
            E = 0,
            z = null,
            A = 0;
          const R = new Uint16Array(16),
            L = new Uint16Array(16);
          let U,
            B,
            Z,
            I = null,
            S = 0;
          for (g = 0; g <= 15; g++) R[g] = 0;
          for (m = 0; m < n; m++) R[e[a + m]]++;
          for (p = l, b = 15; b >= 1 && 0 === R[b]; b--);
          if ((p > b && (p = b), 0 === b))
            return (i[s++] = 20971520), (i[s++] = 20971520), (o.bits = 1), 0;
          for (w = 1; w < b && 0 === R[w]; w++);
          for (p < w && (p = w), y = 1, g = 1; g <= 15; g++)
            if (((y <<= 1), (y -= R[g]), y < 0)) return -1;
          if (y > 0 && (0 === t || 1 !== b)) return -1;
          for (L[1] = 0, g = 1; g < 15; g++) L[g + 1] = L[g] + R[g];
          for (m = 0; m < n; m++) 0 !== e[a + m] && (r[L[e[a + m]]++] = m);
          if (
            (0 === t
              ? ((z = I = r), (u = 19))
              : 1 === t
              ? ((z = re), (A -= 257), (I = oe), (S -= 257), (u = 256))
              : ((z = le), (I = de), (u = -1)),
            (E = 0),
            (m = 0),
            (g = w),
            (f = s),
            (v = p),
            (k = 0),
            (c = -1),
            (x = 1 << p),
            (_ = x - 1),
            (1 === t && x > 852) || (2 === t && x > 592))
          )
            return 1;
          for (;;) {
            (U = g - k),
              r[m] < u
                ? ((B = 0), (Z = r[m]))
                : r[m] > u
                ? ((B = I[S + r[m]]), (Z = z[A + r[m]]))
                : ((B = 96), (Z = 0)),
              (d = 1 << (g - k)),
              (h = 1 << v),
              (w = h);
            do {
              (h -= d), (i[f + (E >> k) + h] = (U << 24) | (B << 16) | Z | 0);
            } while (0 !== h);
            for (d = 1 << (g - 1); E & d; ) d >>= 1;
            if (
              (0 !== d ? ((E &= d - 1), (E += d)) : (E = 0), m++, 0 == --R[g])
            ) {
              if (g === b) break;
              g = e[a + r[m]];
            }
            if (g > p && (E & _) !== c) {
              for (
                0 === k && (k = p), f += w, v = g - k, y = 1 << v;
                v + k < b && ((y -= R[v + k]), !(y <= 0));

              )
                v++, (y <<= 1);
              if (((x += 1 << v), (1 === t && x > 852) || (2 === t && x > 592)))
                return 1;
              (c = E & _), (i[c] = (p << 24) | (v << 16) | (f - s) | 0);
            }
          }
          return (
            0 !== E && (i[f + E] = ((g - k) << 24) | (64 << 16) | 0),
            (o.bits = p),
            0
          );
        };
        const {
            Z_FINISH: ce,
            Z_BLOCK: _e,
            Z_TREES: fe,
            Z_OK: ue,
            Z_STREAM_END: ge,
            Z_NEED_DICT: me,
            Z_STREAM_ERROR: we,
            Z_DATA_ERROR: be,
            Z_MEM_ERROR: pe,
            Z_BUF_ERROR: ve,
            Z_DEFLATED: ke,
          } = F,
          ye = 12,
          xe = 30,
          Ee = (t) =>
            ((t >>> 24) & 255) +
            ((t >>> 8) & 65280) +
            ((65280 & t) << 8) +
            ((255 & t) << 24);
        function ze() {
          (this.mode = 0),
            (this.last = !1),
            (this.wrap = 0),
            (this.havedict = !1),
            (this.flags = 0),
            (this.dmax = 0),
            (this.check = 0),
            (this.total = 0),
            (this.head = null),
            (this.wbits = 0),
            (this.wsize = 0),
            (this.whave = 0),
            (this.wnext = 0),
            (this.window = null),
            (this.hold = 0),
            (this.bits = 0),
            (this.length = 0),
            (this.offset = 0),
            (this.extra = 0),
            (this.lencode = null),
            (this.distcode = null),
            (this.lenbits = 0),
            (this.distbits = 0),
            (this.ncode = 0),
            (this.nlen = 0),
            (this.ndist = 0),
            (this.have = 0),
            (this.next = null),
            (this.lens = new Uint16Array(320)),
            (this.work = new Uint16Array(288)),
            (this.lendyn = null),
            (this.distdyn = null),
            (this.sane = 0),
            (this.back = 0),
            (this.was = 0);
        }
        const Ae = (t) => {
            if (!t || !t.state) return we;
            const e = t.state;
            return (
              (t.total_in = t.total_out = e.total = 0),
              (t.msg = ""),
              e.wrap && (t.adler = 1 & e.wrap),
              (e.mode = 1),
              (e.last = 0),
              (e.havedict = 0),
              (e.dmax = 32768),
              (e.head = null),
              (e.hold = 0),
              (e.bits = 0),
              (e.lencode = e.lendyn = new Int32Array(852)),
              (e.distcode = e.distdyn = new Int32Array(592)),
              (e.sane = 1),
              (e.back = -1),
              ue
            );
          },
          Re = (t) => {
            if (!t || !t.state) return we;
            const e = t.state;
            return (e.wsize = 0), (e.whave = 0), (e.wnext = 0), Ae(t);
          },
          Le = (t, e) => {
            let a;
            if (!t || !t.state) return we;
            const n = t.state;
            return (
              e < 0
                ? ((a = 0), (e = -e))
                : ((a = 1 + (e >> 4)), e < 48 && (e &= 15)),
              e && (e < 8 || e > 15)
                ? we
                : (null !== n.window && n.wbits !== e && (n.window = null),
                  (n.wrap = a),
                  (n.wbits = e),
                  Re(t))
            );
          },
          Ue = (t, e) => {
            if (!t) return we;
            const a = new ze();
            (t.state = a), (a.window = null);
            const n = Le(t, e);
            return n !== ue && (t.state = null), n;
          };
        let Be,
          Ze,
          Ie = !0;
        const Se = (t) => {
            if (Ie) {
              (Be = new Int32Array(512)), (Ze = new Int32Array(32));
              let e = 0;
              for (; e < 144; ) t.lens[e++] = 8;
              for (; e < 256; ) t.lens[e++] = 9;
              for (; e < 280; ) t.lens[e++] = 7;
              for (; e < 288; ) t.lens[e++] = 8;
              for (
                he(1, t.lens, 0, 288, Be, 0, t.work, { bits: 9 }), e = 0;
                e < 32;

              )
                t.lens[e++] = 5;
              he(2, t.lens, 0, 32, Ze, 0, t.work, { bits: 5 }), (Ie = !1);
            }
            (t.lencode = Be),
              (t.lenbits = 9),
              (t.distcode = Ze),
              (t.distbits = 5);
          },
          Oe = (t, e, a, n) => {
            let i;
            const s = t.state;
            return (
              null === s.window &&
                ((s.wsize = 1 << s.wbits),
                (s.wnext = 0),
                (s.whave = 0),
                (s.window = new Uint8Array(s.wsize))),
              n >= s.wsize
                ? (s.window.set(e.subarray(a - s.wsize, a), 0),
                  (s.wnext = 0),
                  (s.whave = s.wsize))
                : ((i = s.wsize - s.wnext),
                  i > n && (i = n),
                  s.window.set(e.subarray(a - n, a - n + i), s.wnext),
                  (n -= i)
                    ? (s.window.set(e.subarray(a - n, a), 0),
                      (s.wnext = n),
                      (s.whave = s.wsize))
                    : ((s.wnext += i),
                      s.wnext === s.wsize && (s.wnext = 0),
                      s.whave < s.wsize && (s.whave += i))),
              0
            );
          };
        var Ce = Re,
          Te = Ue,
          De = (t, e) => {
            let a,
              n,
              i,
              s,
              r,
              o,
              l,
              d,
              h,
              c,
              _,
              f,
              u,
              g,
              m,
              w,
              b,
              p,
              v,
              k,
              y,
              x,
              E = 0;
            const z = new Uint8Array(4);
            let A, R;
            const L = new Uint8Array([
              16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
            ]);
            if (!t || !t.state || !t.output || (!t.input && 0 !== t.avail_in))
              return we;
            (a = t.state),
              a.mode === ye && (a.mode = 13),
              (r = t.next_out),
              (i = t.output),
              (l = t.avail_out),
              (s = t.next_in),
              (n = t.input),
              (o = t.avail_in),
              (d = a.hold),
              (h = a.bits),
              (c = o),
              (_ = l),
              (x = ue);
            t: for (;;)
              switch (a.mode) {
                case 1:
                  if (0 === a.wrap) {
                    a.mode = 13;
                    break;
                  }
                  for (; h < 16; ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  if (2 & a.wrap && 35615 === d) {
                    (a.check = 0),
                      (z[0] = 255 & d),
                      (z[1] = (d >>> 8) & 255),
                      (a.check = T(a.check, z, 2, 0)),
                      (d = 0),
                      (h = 0),
                      (a.mode = 2);
                    break;
                  }
                  if (
                    ((a.flags = 0),
                    a.head && (a.head.done = !1),
                    !(1 & a.wrap) || (((255 & d) << 8) + (d >> 8)) % 31)
                  ) {
                    (t.msg = "incorrect header check"), (a.mode = xe);
                    break;
                  }
                  if ((15 & d) !== ke) {
                    (t.msg = "unknown compression method"), (a.mode = xe);
                    break;
                  }
                  if (((d >>>= 4), (h -= 4), (y = 8 + (15 & d)), 0 === a.wbits))
                    a.wbits = y;
                  else if (y > a.wbits) {
                    (t.msg = "invalid window size"), (a.mode = xe);
                    break;
                  }
                  (a.dmax = 1 << a.wbits),
                    (t.adler = a.check = 1),
                    (a.mode = 512 & d ? 10 : ye),
                    (d = 0),
                    (h = 0);
                  break;
                case 2:
                  for (; h < 16; ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  if (((a.flags = d), (255 & a.flags) !== ke)) {
                    (t.msg = "unknown compression method"), (a.mode = xe);
                    break;
                  }
                  if (57344 & a.flags) {
                    (t.msg = "unknown header flags set"), (a.mode = xe);
                    break;
                  }
                  a.head && (a.head.text = (d >> 8) & 1),
                    512 & a.flags &&
                      ((z[0] = 255 & d),
                      (z[1] = (d >>> 8) & 255),
                      (a.check = T(a.check, z, 2, 0))),
                    (d = 0),
                    (h = 0),
                    (a.mode = 3);
                case 3:
                  for (; h < 32; ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  a.head && (a.head.time = d),
                    512 & a.flags &&
                      ((z[0] = 255 & d),
                      (z[1] = (d >>> 8) & 255),
                      (z[2] = (d >>> 16) & 255),
                      (z[3] = (d >>> 24) & 255),
                      (a.check = T(a.check, z, 4, 0))),
                    (d = 0),
                    (h = 0),
                    (a.mode = 4);
                case 4:
                  for (; h < 16; ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  a.head && ((a.head.xflags = 255 & d), (a.head.os = d >> 8)),
                    512 & a.flags &&
                      ((z[0] = 255 & d),
                      (z[1] = (d >>> 8) & 255),
                      (a.check = T(a.check, z, 2, 0))),
                    (d = 0),
                    (h = 0),
                    (a.mode = 5);
                case 5:
                  if (1024 & a.flags) {
                    for (; h < 16; ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    (a.length = d),
                      a.head && (a.head.extra_len = d),
                      512 & a.flags &&
                        ((z[0] = 255 & d),
                        (z[1] = (d >>> 8) & 255),
                        (a.check = T(a.check, z, 2, 0))),
                      (d = 0),
                      (h = 0);
                  } else a.head && (a.head.extra = null);
                  a.mode = 6;
                case 6:
                  if (
                    1024 & a.flags &&
                    ((f = a.length),
                    f > o && (f = o),
                    f &&
                      (a.head &&
                        ((y = a.head.extra_len - a.length),
                        a.head.extra ||
                          (a.head.extra = new Uint8Array(a.head.extra_len)),
                        a.head.extra.set(n.subarray(s, s + f), y)),
                      512 & a.flags && (a.check = T(a.check, n, f, s)),
                      (o -= f),
                      (s += f),
                      (a.length -= f)),
                    a.length)
                  )
                    break t;
                  (a.length = 0), (a.mode = 7);
                case 7:
                  if (2048 & a.flags) {
                    if (0 === o) break t;
                    f = 0;
                    do {
                      (y = n[s + f++]),
                        a.head &&
                          y &&
                          a.length < 65536 &&
                          (a.head.name += String.fromCharCode(y));
                    } while (y && f < o);
                    if (
                      (512 & a.flags && (a.check = T(a.check, n, f, s)),
                      (o -= f),
                      (s += f),
                      y)
                    )
                      break t;
                  } else a.head && (a.head.name = null);
                  (a.length = 0), (a.mode = 8);
                case 8:
                  if (4096 & a.flags) {
                    if (0 === o) break t;
                    f = 0;
                    do {
                      (y = n[s + f++]),
                        a.head &&
                          y &&
                          a.length < 65536 &&
                          (a.head.comment += String.fromCharCode(y));
                    } while (y && f < o);
                    if (
                      (512 & a.flags && (a.check = T(a.check, n, f, s)),
                      (o -= f),
                      (s += f),
                      y)
                    )
                      break t;
                  } else a.head && (a.head.comment = null);
                  a.mode = 9;
                case 9:
                  if (512 & a.flags) {
                    for (; h < 16; ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    if (d !== (65535 & a.check)) {
                      (t.msg = "header crc mismatch"), (a.mode = xe);
                      break;
                    }
                    (d = 0), (h = 0);
                  }
                  a.head &&
                    ((a.head.hcrc = (a.flags >> 9) & 1), (a.head.done = !0)),
                    (t.adler = a.check = 0),
                    (a.mode = ye);
                  break;
                case 10:
                  for (; h < 32; ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  (t.adler = a.check = Ee(d)), (d = 0), (h = 0), (a.mode = 11);
                case 11:
                  if (0 === a.havedict)
                    return (
                      (t.next_out = r),
                      (t.avail_out = l),
                      (t.next_in = s),
                      (t.avail_in = o),
                      (a.hold = d),
                      (a.bits = h),
                      me
                    );
                  (t.adler = a.check = 1), (a.mode = ye);
                case ye:
                  if (e === _e || e === fe) break t;
                case 13:
                  if (a.last) {
                    (d >>>= 7 & h), (h -= 7 & h), (a.mode = 27);
                    break;
                  }
                  for (; h < 3; ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  switch (((a.last = 1 & d), (d >>>= 1), (h -= 1), 3 & d)) {
                    case 0:
                      a.mode = 14;
                      break;
                    case 1:
                      if ((Se(a), (a.mode = 20), e === fe)) {
                        (d >>>= 2), (h -= 2);
                        break t;
                      }
                      break;
                    case 2:
                      a.mode = 17;
                      break;
                    case 3:
                      (t.msg = "invalid block type"), (a.mode = xe);
                  }
                  (d >>>= 2), (h -= 2);
                  break;
                case 14:
                  for (d >>>= 7 & h, h -= 7 & h; h < 32; ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  if ((65535 & d) != ((d >>> 16) ^ 65535)) {
                    (t.msg = "invalid stored block lengths"), (a.mode = xe);
                    break;
                  }
                  if (
                    ((a.length = 65535 & d),
                    (d = 0),
                    (h = 0),
                    (a.mode = 15),
                    e === fe)
                  )
                    break t;
                case 15:
                  a.mode = 16;
                case 16:
                  if (((f = a.length), f)) {
                    if ((f > o && (f = o), f > l && (f = l), 0 === f)) break t;
                    i.set(n.subarray(s, s + f), r),
                      (o -= f),
                      (s += f),
                      (l -= f),
                      (r += f),
                      (a.length -= f);
                    break;
                  }
                  a.mode = ye;
                  break;
                case 17:
                  for (; h < 14; ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  if (
                    ((a.nlen = 257 + (31 & d)),
                    (d >>>= 5),
                    (h -= 5),
                    (a.ndist = 1 + (31 & d)),
                    (d >>>= 5),
                    (h -= 5),
                    (a.ncode = 4 + (15 & d)),
                    (d >>>= 4),
                    (h -= 4),
                    a.nlen > 286 || a.ndist > 30)
                  ) {
                    (t.msg = "too many length or distance symbols"),
                      (a.mode = xe);
                    break;
                  }
                  (a.have = 0), (a.mode = 18);
                case 18:
                  for (; a.have < a.ncode; ) {
                    for (; h < 3; ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    (a.lens[L[a.have++]] = 7 & d), (d >>>= 3), (h -= 3);
                  }
                  for (; a.have < 19; ) a.lens[L[a.have++]] = 0;
                  if (
                    ((a.lencode = a.lendyn),
                    (a.lenbits = 7),
                    (A = { bits: a.lenbits }),
                    (x = he(0, a.lens, 0, 19, a.lencode, 0, a.work, A)),
                    (a.lenbits = A.bits),
                    x)
                  ) {
                    (t.msg = "invalid code lengths set"), (a.mode = xe);
                    break;
                  }
                  (a.have = 0), (a.mode = 19);
                case 19:
                  for (; a.have < a.nlen + a.ndist; ) {
                    for (
                      ;
                      (E = a.lencode[d & ((1 << a.lenbits) - 1)]),
                        (m = E >>> 24),
                        (w = (E >>> 16) & 255),
                        (b = 65535 & E),
                        !(m <= h);

                    ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    if (b < 16) (d >>>= m), (h -= m), (a.lens[a.have++] = b);
                    else {
                      if (16 === b) {
                        for (R = m + 2; h < R; ) {
                          if (0 === o) break t;
                          o--, (d += n[s++] << h), (h += 8);
                        }
                        if (((d >>>= m), (h -= m), 0 === a.have)) {
                          (t.msg = "invalid bit length repeat"), (a.mode = xe);
                          break;
                        }
                        (y = a.lens[a.have - 1]),
                          (f = 3 + (3 & d)),
                          (d >>>= 2),
                          (h -= 2);
                      } else if (17 === b) {
                        for (R = m + 3; h < R; ) {
                          if (0 === o) break t;
                          o--, (d += n[s++] << h), (h += 8);
                        }
                        (d >>>= m),
                          (h -= m),
                          (y = 0),
                          (f = 3 + (7 & d)),
                          (d >>>= 3),
                          (h -= 3);
                      } else {
                        for (R = m + 7; h < R; ) {
                          if (0 === o) break t;
                          o--, (d += n[s++] << h), (h += 8);
                        }
                        (d >>>= m),
                          (h -= m),
                          (y = 0),
                          (f = 11 + (127 & d)),
                          (d >>>= 7),
                          (h -= 7);
                      }
                      if (a.have + f > a.nlen + a.ndist) {
                        (t.msg = "invalid bit length repeat"), (a.mode = xe);
                        break;
                      }
                      for (; f--; ) a.lens[a.have++] = y;
                    }
                  }
                  if (a.mode === xe) break;
                  if (0 === a.lens[256]) {
                    (t.msg = "invalid code -- missing end-of-block"),
                      (a.mode = xe);
                    break;
                  }
                  if (
                    ((a.lenbits = 9),
                    (A = { bits: a.lenbits }),
                    (x = he(1, a.lens, 0, a.nlen, a.lencode, 0, a.work, A)),
                    (a.lenbits = A.bits),
                    x)
                  ) {
                    (t.msg = "invalid literal/lengths set"), (a.mode = xe);
                    break;
                  }
                  if (
                    ((a.distbits = 6),
                    (a.distcode = a.distdyn),
                    (A = { bits: a.distbits }),
                    (x = he(
                      2,
                      a.lens,
                      a.nlen,
                      a.ndist,
                      a.distcode,
                      0,
                      a.work,
                      A
                    )),
                    (a.distbits = A.bits),
                    x)
                  ) {
                    (t.msg = "invalid distances set"), (a.mode = xe);
                    break;
                  }
                  if (((a.mode = 20), e === fe)) break t;
                case 20:
                  a.mode = 21;
                case 21:
                  if (o >= 6 && l >= 258) {
                    (t.next_out = r),
                      (t.avail_out = l),
                      (t.next_in = s),
                      (t.avail_in = o),
                      (a.hold = d),
                      (a.bits = h),
                      se(t, _),
                      (r = t.next_out),
                      (i = t.output),
                      (l = t.avail_out),
                      (s = t.next_in),
                      (n = t.input),
                      (o = t.avail_in),
                      (d = a.hold),
                      (h = a.bits),
                      a.mode === ye && (a.back = -1);
                    break;
                  }
                  for (
                    a.back = 0;
                    (E = a.lencode[d & ((1 << a.lenbits) - 1)]),
                      (m = E >>> 24),
                      (w = (E >>> 16) & 255),
                      (b = 65535 & E),
                      !(m <= h);

                  ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  if (w && 0 == (240 & w)) {
                    for (
                      p = m, v = w, k = b;
                      (E = a.lencode[k + ((d & ((1 << (p + v)) - 1)) >> p)]),
                        (m = E >>> 24),
                        (w = (E >>> 16) & 255),
                        (b = 65535 & E),
                        !(p + m <= h);

                    ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    (d >>>= p), (h -= p), (a.back += p);
                  }
                  if (
                    ((d >>>= m),
                    (h -= m),
                    (a.back += m),
                    (a.length = b),
                    0 === w)
                  ) {
                    a.mode = 26;
                    break;
                  }
                  if (32 & w) {
                    (a.back = -1), (a.mode = ye);
                    break;
                  }
                  if (64 & w) {
                    (t.msg = "invalid literal/length code"), (a.mode = xe);
                    break;
                  }
                  (a.extra = 15 & w), (a.mode = 22);
                case 22:
                  if (a.extra) {
                    for (R = a.extra; h < R; ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    (a.length += d & ((1 << a.extra) - 1)),
                      (d >>>= a.extra),
                      (h -= a.extra),
                      (a.back += a.extra);
                  }
                  (a.was = a.length), (a.mode = 23);
                case 23:
                  for (
                    ;
                    (E = a.distcode[d & ((1 << a.distbits) - 1)]),
                      (m = E >>> 24),
                      (w = (E >>> 16) & 255),
                      (b = 65535 & E),
                      !(m <= h);

                  ) {
                    if (0 === o) break t;
                    o--, (d += n[s++] << h), (h += 8);
                  }
                  if (0 == (240 & w)) {
                    for (
                      p = m, v = w, k = b;
                      (E = a.distcode[k + ((d & ((1 << (p + v)) - 1)) >> p)]),
                        (m = E >>> 24),
                        (w = (E >>> 16) & 255),
                        (b = 65535 & E),
                        !(p + m <= h);

                    ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    (d >>>= p), (h -= p), (a.back += p);
                  }
                  if (((d >>>= m), (h -= m), (a.back += m), 64 & w)) {
                    (t.msg = "invalid distance code"), (a.mode = xe);
                    break;
                  }
                  (a.offset = b), (a.extra = 15 & w), (a.mode = 24);
                case 24:
                  if (a.extra) {
                    for (R = a.extra; h < R; ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    (a.offset += d & ((1 << a.extra) - 1)),
                      (d >>>= a.extra),
                      (h -= a.extra),
                      (a.back += a.extra);
                  }
                  if (a.offset > a.dmax) {
                    (t.msg = "invalid distance too far back"), (a.mode = xe);
                    break;
                  }
                  a.mode = 25;
                case 25:
                  if (0 === l) break t;
                  if (((f = _ - l), a.offset > f)) {
                    if (((f = a.offset - f), f > a.whave && a.sane)) {
                      (t.msg = "invalid distance too far back"), (a.mode = xe);
                      break;
                    }
                    f > a.wnext
                      ? ((f -= a.wnext), (u = a.wsize - f))
                      : (u = a.wnext - f),
                      f > a.length && (f = a.length),
                      (g = a.window);
                  } else (g = i), (u = r - a.offset), (f = a.length);
                  f > l && (f = l), (l -= f), (a.length -= f);
                  do {
                    i[r++] = g[u++];
                  } while (--f);
                  0 === a.length && (a.mode = 21);
                  break;
                case 26:
                  if (0 === l) break t;
                  (i[r++] = a.length), l--, (a.mode = 21);
                  break;
                case 27:
                  if (a.wrap) {
                    for (; h < 32; ) {
                      if (0 === o) break t;
                      o--, (d |= n[s++] << h), (h += 8);
                    }
                    if (
                      ((_ -= l),
                      (t.total_out += _),
                      (a.total += _),
                      _ &&
                        (t.adler = a.check =
                          a.flags
                            ? T(a.check, i, _, r - _)
                            : O(a.check, i, _, r - _)),
                      (_ = l),
                      (a.flags ? d : Ee(d)) !== a.check)
                    ) {
                      (t.msg = "incorrect data check"), (a.mode = xe);
                      break;
                    }
                    (d = 0), (h = 0);
                  }
                  a.mode = 28;
                case 28:
                  if (a.wrap && a.flags) {
                    for (; h < 32; ) {
                      if (0 === o) break t;
                      o--, (d += n[s++] << h), (h += 8);
                    }
                    if (d !== (4294967295 & a.total)) {
                      (t.msg = "incorrect length check"), (a.mode = xe);
                      break;
                    }
                    (d = 0), (h = 0);
                  }
                  a.mode = 29;
                case 29:
                  x = ge;
                  break t;
                case xe:
                  x = be;
                  break t;
                case 31:
                  return pe;
                default:
                  return we;
              }
            return (
              (t.next_out = r),
              (t.avail_out = l),
              (t.next_in = s),
              (t.avail_in = o),
              (a.hold = d),
              (a.bits = h),
              (a.wsize ||
                (_ !== t.avail_out &&
                  a.mode < xe &&
                  (a.mode < 27 || e !== ce))) &&
                Oe(t, t.output, t.next_out, _ - t.avail_out),
              (c -= t.avail_in),
              (_ -= t.avail_out),
              (t.total_in += c),
              (t.total_out += _),
              (a.total += _),
              a.wrap &&
                _ &&
                (t.adler = a.check =
                  a.flags
                    ? T(a.check, i, _, t.next_out - _)
                    : O(a.check, i, _, t.next_out - _)),
              (t.data_type =
                a.bits +
                (a.last ? 64 : 0) +
                (a.mode === ye ? 128 : 0) +
                (20 === a.mode || 15 === a.mode ? 256 : 0)),
              ((0 === c && 0 === _) || e === ce) && x === ue && (x = ve),
              x
            );
          },
          Fe = (t) => {
            if (!t || !t.state) return we;
            let e = t.state;
            return e.window && (e.window = null), (t.state = null), ue;
          },
          Ne = (t, e) => {
            if (!t || !t.state) return we;
            const a = t.state;
            return 0 == (2 & a.wrap) ? we : ((a.head = e), (e.done = !1), ue);
          },
          He = (t, e) => {
            const a = e.length;
            let n, i, s;
            return t && t.state
              ? ((n = t.state),
                0 !== n.wrap && 11 !== n.mode
                  ? we
                  : 11 === n.mode &&
                    ((i = 1), (i = O(i, e, a, 0)), i !== n.check)
                  ? be
                  : ((s = Oe(t, e, a, a)),
                    s ? ((n.mode = 31), pe) : ((n.havedict = 1), ue)))
              : we;
          },
          Me = function () {
            (this.text = 0),
              (this.time = 0),
              (this.xflags = 0),
              (this.os = 0),
              (this.extra = null),
              (this.extra_len = 0),
              (this.name = ""),
              (this.comment = ""),
              (this.hcrc = 0),
              (this.done = !1);
          };
        const je = Object.prototype.toString,
          {
            Z_NO_FLUSH: Pe,
            Z_FINISH: We,
            Z_OK: Ye,
            Z_STREAM_END: Ke,
            Z_NEED_DICT: Xe,
            Z_STREAM_ERROR: $e,
            Z_DATA_ERROR: Ge,
            Z_MEM_ERROR: qe,
          } = F;
        function Je(t) {
          this.options = Ft(
            { chunkSize: 65536, windowBits: 15, to: "" },
            t || {}
          );
          const e = this.options;
          e.raw &&
            e.windowBits >= 0 &&
            e.windowBits < 16 &&
            ((e.windowBits = -e.windowBits),
            0 === e.windowBits && (e.windowBits = -15)),
            !(e.windowBits >= 0 && e.windowBits < 16) ||
              (t && t.windowBits) ||
              (e.windowBits += 32),
            e.windowBits > 15 &&
              e.windowBits < 48 &&
              0 == (15 & e.windowBits) &&
              (e.windowBits |= 15),
            (this.err = 0),
            (this.msg = ""),
            (this.ended = !1),
            (this.chunks = []),
            (this.strm = new Yt()),
            (this.strm.avail_out = 0);
          let a = Te(this.strm, e.windowBits);
          if (a !== Ye) throw new Error(D[a]);
          if (
            ((this.header = new Me()),
            Ne(this.strm, this.header),
            e.dictionary &&
              ("string" == typeof e.dictionary
                ? (e.dictionary = jt(e.dictionary))
                : "[object ArrayBuffer]" === je.call(e.dictionary) &&
                  (e.dictionary = new Uint8Array(e.dictionary)),
              e.raw && ((a = He(this.strm, e.dictionary)), a !== Ye)))
          )
            throw new Error(D[a]);
        }
        function Qe(t, e) {
          const a = new Je(e);
          if ((a.push(t), a.err)) throw a.msg || D[a.err];
          return a.result;
        }
        (Je.prototype.push = function (t, e) {
          const a = this.strm,
            n = this.options.chunkSize,
            i = this.options.dictionary;
          let s, r, o;
          if (this.ended) return !1;
          for (
            r = e === ~~e ? e : !0 === e ? We : Pe,
              "[object ArrayBuffer]" === je.call(t)
                ? (a.input = new Uint8Array(t))
                : (a.input = t),
              a.next_in = 0,
              a.avail_in = a.input.length;
            ;

          ) {
            for (
              0 === a.avail_out &&
                ((a.output = new Uint8Array(n)),
                (a.next_out = 0),
                (a.avail_out = n)),
                s = De(a, r),
                s === Xe &&
                  i &&
                  ((s = He(a, i)),
                  s === Ye ? (s = De(a, r)) : s === Ge && (s = Xe));
              a.avail_in > 0 &&
              s === Ke &&
              a.state.wrap > 0 &&
              0 !== t[a.next_in];

            )
              Ce(a), (s = De(a, r));
            switch (s) {
              case $e:
              case Ge:
              case Xe:
              case qe:
                return this.onEnd(s), (this.ended = !0), !1;
            }
            if (
              ((o = a.avail_out), a.next_out && (0 === a.avail_out || s === Ke))
            )
              if ("string" === this.options.to) {
                let t = Wt(a.output, a.next_out),
                  e = a.next_out - t,
                  i = Pt(a.output, t);
                (a.next_out = e),
                  (a.avail_out = n - e),
                  e && a.output.set(a.output.subarray(t, t + e), 0),
                  this.onData(i);
              } else
                this.onData(
                  a.output.length === a.next_out
                    ? a.output
                    : a.output.subarray(0, a.next_out)
                );
            if (s !== Ye || 0 !== o) {
              if (s === Ke)
                return (
                  (s = Fe(this.strm)), this.onEnd(s), (this.ended = !0), !0
                );
              if (0 === a.avail_in) break;
            }
          }
          return !0;
        }),
          (Je.prototype.onData = function (t) {
            this.chunks.push(t);
          }),
          (Je.prototype.onEnd = function (t) {
            t === Ye &&
              ("string" === this.options.to
                ? (this.result = this.chunks.join(""))
                : (this.result = Nt(this.chunks))),
              (this.chunks = []),
              (this.err = t),
              (this.msg = this.strm.msg);
          });
        var Ve = {
          Inflate: Je,
          inflate: Qe,
          inflateRaw: function (t, e) {
            return ((e = e || {}).raw = !0), Qe(t, e);
          },
          ungzip: Qe,
          constants: F,
        };
        const { Deflate: ta, deflate: ea, deflateRaw: aa, gzip: na } = ie,
          { Inflate: ia, inflate: sa, inflateRaw: ra, ungzip: oa } = Ve;
        var la = ta,
          da = ea,
          ha = aa,
          ca = na,
          _a = ia,
          fa = sa,
          ua = ra,
          ga = oa,
          ma = F,
          wa = {
            Deflate: la,
            deflate: da,
            deflateRaw: ha,
            gzip: ca,
            Inflate: _a,
            inflate: fa,
            inflateRaw: ua,
            ungzip: ga,
            constants: ma,
          };
        (t.Deflate = la),
          (t.Inflate = _a),
          (t.constants = ma),
          (t.default = wa),
          (t.deflate = da),
          (t.deflateRaw = ha),
          (t.gzip = ca),
          (t.inflate = fa),
          (t.inflateRaw = ua),
          (t.ungzip = ga),
          Object.defineProperty(t, "__esModule", { value: !0 });
      }),
        document
          .getElementById("importImage")
          .addEventListener("change", function (t) {
            const e = t.target.files;
            for (const t of e) console.log("File name:", t.name);
          }),
        document
          .getElementById("convertToWebP")
          .addEventListener("click", function () {
            const t = document.getElementById("imageCanvas");
            if (t) {
              t.getContext("2d");
              t.toBlob(function (t) {
                const e = document.createElement("img"),
                  a = URL.createObjectURL(t);
                (e.onload = function () {
                  URL.revokeObjectURL(a);
                }),
                  (e.src = a),
                  document.body.appendChild(e);
              }, "image/webp");
            }
          }),
        document
          .getElementById("convertToPNG")
          .addEventListener("click", function () {
            const t = document.getElementById("imageCanvas");
            if (t) {
              t.getContext("2d");
              t.toBlob(function (t) {
                const e = document.createElement("img"),
                  a = URL.createObjectURL(t);
                (e.onload = function () {
                  URL.revokeObjectURL(a);
                }),
                  (e.src = a),
                  document.body.appendChild(e);
              }, "image/png");
            }
          }),
        document.addEventListener("DOMContentLoaded", () => {
          const t = document.getElementById("canvasContainer"),
            e = document.getElementById("addLayerBtn"),
            a = document.getElementById("clearLayerBtn"),
            n = document.getElementById("layerSelect"),
            i = document.getElementById("colorPicker"),
            s = document.getElementById("brushSize"),
            r = document.getElementById("undoBtn"),
            o = document.getElementById("eraseBtn"),
            l = document.getElementById("fillColor"),
            d = document.getElementById("fillBtn"),
            h = document.getElementById("importImage"),
            c = document.getElementById("convertToWebP"),
            _ = document.getElementById("convertToPNG"),
            f = document.getElementById("compressAndDownload"),
            u = document.getElementById("compressBtn"),
            g = document.getElementById("canvasWidth"),
            m = document.getElementById("canvasHeight"),
            w = document.getElementById("resizeCanvas"),
            b = document.getElementById("exportHTML");
          let p = [],
            v = -1,
            k = [],
            y = !1;
          function x() {
            const e = (function () {
              const e = document.createElement("canvas");
              return (
                (e.width = t.offsetWidth),
                (e.height = t.offsetHeight),
                e.classList.add("drawingCanvas"),
                t.appendChild(e),
                e.getContext("2d")
              );
            })();
            p.push(e), E(p.length - 1), I();
          }
          function E(t) {
            (v = t),
              (n.innerHTML = ""),
              p.forEach((t, e) => {
                const a = document.createElement("option");
                (a.value = e),
                  (a.textContent = `Layer ${e + 1}`),
                  n.appendChild(a);
              }),
              (n.value = v),
              (y = !1);
          }
          function z(t, e = 0.75) {
            p[v].canvas.toBlob(
              function (e) {
                const a = URL.createObjectURL(e),
                  n = document.createElement("a");
                (n.href = a),
                  (n.download = `image.${t}`),
                  document.body.appendChild(n),
                  n.click(),
                  document.body.removeChild(n);
              },
              `image/${t}`,
              e
            );
          }
          e.addEventListener("click", x),
            a.addEventListener("click", function () {
              -1 !== v &&
                (p[v].clearRect(0, 0, t.offsetWidth, t.offsetHeight), I());
            }),
            n.addEventListener("change", (t) =>
              E(parseInt(t.target.value, 10))
            ),
            i.addEventListener("change", (t) => {
              return (
                (e = t.target.value),
                void (-1 === v || y || (p[v].strokeStyle = e))
              );
              var e;
            }),
            s.addEventListener("change", (t) => {
              return (
                (e = t.target.value), void (-1 !== v && (p[v].lineWidth = e))
              );
              var e;
            }),
            r.addEventListener("click", function () {
              if (k.length > 0) {
                k.pop();
                const e = k[k.length - 1],
                  a = new Image();
                (a.onload = function () {
                  p[v].clearRect(0, 0, t.offsetWidth, t.offsetHeight),
                    p[v].drawImage(a, 0, 0, t.offsetWidth, t.offsetHeight);
                }),
                  (a.src = e);
              }
            }),
            o.addEventListener("click", function () {
              (y = !y),
                y
                  ? ((p[v].globalCompositeOperation = "destination-out"),
                    (p[v].strokeStyle = "rgba(0,0,0,1)"),
                    (p[v].lineWidth = s.value))
                  : ((p[v].globalCompositeOperation = "source-over"),
                    (p[v].strokeStyle = i.value));
            }),
            d.addEventListener("click", function () {
              -1 !== v &&
                ((p[v].fillStyle = l.value),
                p[v].fillRect(0, 0, t.offsetWidth, t.offsetHeight),
                I());
            }),
            h.addEventListener("change", function (e) {
              const a = e.target.files[0];
              if (a) {
                const e = new FileReader();
                (e.onload = function (e) {
                  const a = new Image();
                  (a.onload = function () {
                    x(),
                      p[v].drawImage(a, 0, 0, t.offsetWidth, t.offsetHeight),
                      I();
                  }),
                    (a.src = e.target.result);
                }),
                  e.readAsDataURL(a);
              }
            }),
            c.addEventListener("click", () => z("webp", 0.75)),
            _.addEventListener("click", () => z("png")),
            f.addEventListener("click", function () {
              p[v].canvas.toBlob((t) => {
                const e = new FileReader();
                e.readAsArrayBuffer(t),
                  (e.onloadend = function () {
                    const t = pako.gzip(new Uint8Array(e.result)),
                      a = new Blob([t], { type: "application/gzip" }),
                      n = URL.createObjectURL(a),
                      i = document.createElement("a");
                    (i.href = n),
                      (i.download = "canvas.gz"),
                      document.body.appendChild(i),
                      i.click(),
                      document.body.removeChild(i);
                  });
              }, "image/png");
            }),
            u.addEventListener("click", function () {
              p[v].canvas.toBlob((t) => {
                const e = new FileReader();
                e.readAsArrayBuffer(t),
                  (e.onloadend = function () {
                    const t = pako.gzip(new Uint8Array(e.result));
                    console.log("Compressed size:", t.byteLength, "bytes"),
                      alert("Canvas data compressed successfully!");
                  });
              }, "image/png");
            }),
            w.addEventListener("click", function () {
              const e = parseInt(g.value, 10),
                a = parseInt(m.value, 10);
              (t.style.width = `${e}px`),
                (t.style.height = `${a}px`),
                p.forEach((t) => {
                  const n = t.canvas;
                  (n.width = e), (n.height = a);
                });
            }),
            b.addEventListener("click", function () {
              const t = `<!DOCTYPE html>\n                <html lang="en">\n                <head>\n                    <meta charset="UTF-8">\n                    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n                    <title>Exported Canvas</title>\n                </head>\n                <body style="margin: 0; background-color: #fafafa;">\n                    <img src="${p[
                  v
                ].canvas.toDataURL()}"/>\n                </body>\n                </html>`,
                e = new Blob([t], { type: "text/html" }),
                a = URL.createObjectURL(e),
                n = document.createElement("a");
              (n.href = a),
                (n.download = "exported_canvas.html"),
                document.body.appendChild(n),
                n.click(),
                document.body.removeChild(n);
            });
          let A = !1,
            R = 0,
            L = 0;
          function U(e) {
            e.preventDefault(),
              (A = !0),
              (R = e.clientX || e.touches[0].clientX - t.offsetLeft),
              (L = e.clientY || e.touches[0].clientY - t.offsetTop),
              p[v].beginPath();
          }
          function B(e) {
            if (!A) return;
            e.preventDefault();
            const a = (e.clientX || e.touches[0].clientX) - t.offsetLeft,
              n = (e.clientY || e.touches[0].clientY) - t.offsetTop;
            p[v].lineTo(a, n), p[v].stroke(), (R = a), (L = n);
          }
          function Z() {
            (A = !1), p[v].closePath(), I();
          }
          function I() {
            const t = p[v].canvas.toDataURL();
            k.push(t);
          }
          t.addEventListener("mousedown", (t) => U(t)),
            t.addEventListener("mousemove", (t) => B(t)),
            t.addEventListener("mouseup", () => Z()),
            t.addEventListener("mouseout", () => Z()),
            t.addEventListener("touchstart", (t) => U(t.touches[0]), {
              passive: !1,
            }),
            t.addEventListener("touchmove", (t) => B(t.touches[0]), {
              passive: !1,
            }),
            t.addEventListener("touchend", () => Z(), { passive: !1 }),
            t.addEventListener("touchcancel", () => Z(), { passive: !1 }),
            x();
        });
    </script>
  </body>
</html>